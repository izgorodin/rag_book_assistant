AByte ofPython (Russian)
Версия 2.01
Swaroop CH(Translated byVladimir Smolyar)
22August2013


Оглавление
1 Обложка 1
1.1 «УкусПитона»–«AByteofPython»по-русски . . . . . . . . . . . . . . . . . 1
1.2 Кточитает«AByteofPython»? . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.3 Лицензия . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.4 Читать . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.5 Купитькнигу . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.6 Скачать . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.7 Книганавашемродномязыке . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
2 Переводы 7
2.1 Доступныепереводы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
3 Предисловие 15
3.1 Длякогоэтакнига . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
3.2 Немногоистории . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
3.3 Состояниекниги . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
3.4 Официальнаявеб-страница . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
3.5 Кразмышлению . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
4 Введение 19
4.1 ОсобенностиPython . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
4.2 Python2против3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
4.3 Чтоговорятпрограммисты . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
5 Установка 23
5.1 УстановкавGNU/LinuxиBSD . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
5.2 УстановкавWindows . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
5.3 ДляпользователейMacOSX . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
i
5.4 Резюме . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
6 Первые шаги 27
6.1 Введение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
6.2 Использованиекоманднойстрокиинтерпретатора . . . . . . . . . . . . . . 27
6.3 Выборредактора . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
6.4 Использованиепрограммныхфайлов . . . . . . . . . . . . . . . . . . . . . . . 29
6.5 Получениепомощи . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
6.6 Резюме . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
7 Основы 35
7.1 Комментарии . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
7.2 Литеральныеконстанты . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
7.3 Числа . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
7.4 Строки . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
7.5 Переменные . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
7.6 Именаидентификаторов . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
7.7 Типыданных . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
7.8 Объекты . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
7.9 Логическиеифизическиестроки . . . . . . . . . . . . . . . . . . . . . . . . . 41
7.10 Отступы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
7.11 Резюме . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
8 Операторы и выражения 45
8.1 Операторы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
8.2 Порядоквычисления . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
8.3 Изменениепорядкавычисления . . . . . . . . . . . . . . . . . . . . . . . . . . 49
8.4 Ассоциативность . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
8.5 Выражения . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
8.6 Резюме . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
9 Поток команд 51
9.1 Операторif . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
9.2 Операторwhile . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
9.3 Циклfor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
9.4 Операторbreak . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
9.5 Операторcontinue . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
9.6 Резюме . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
10 Функции 59
10.1 Параметрыфункций . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
10.2 Локальныепеременные . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
10.3 Зарезервированноеслово«global» . . . . . . . . . . . . . . . . . . . . . . . . . 61
10.4 Зарезервированноеслово«nonlocal» . . . . . . . . . . . . . . . . . . . . . . . 62
10.5 Значенияаргументовпоумолчанию . . . . . . . . . . . . . . . . . . . . . . . 63
ii
10.6 Ключевыеаргументы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
10.7 Переменноечислопараметров . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
10.8 Толькоключевыепараметры . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
10.9 Оператор«return» . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67
10.10 Строкидокументации . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
10.11 Аннотации . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
10.12 Резюме . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
11 Модули 71
11.1 Файлыбайткода.pyc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
11.2 Операторfrom…import… . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
11.3 Имямодуля–__name__ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
11.4 Созданиесобственныхмодулей . . . . . . . . . . . . . . . . . . . . . . . . . . 75
11.5 Функцияdir . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
11.6 Пакеты . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
11.7 Резюме . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78
12 Структуры данных 79
12.1 Список . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
12.2 Краткоевведениевобъектыиклассы . . . . . . . . . . . . . . . . . . . . . . . 79
12.3 Кортеж . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
12.4 Словарь . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
12.5 Последовательности . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85
12.6 Множество . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
12.7 Ссылки . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
12.8 Ещёостроках . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
12.9 Резюме . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
13 Решение задач 91
13.1 Задача . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
13.2 Решение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
13.3 Втораяверсия . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
13.4 Третьяверсия . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
13.5 Четвёртаяверсия . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
13.6 Дополнительныеусовершенствования . . . . . . . . . . . . . . . . . . . . . . 99
13.7 Процессразработкипрограммногообеспечения . . . . . . . . . . . . . . . . 99
13.8 Резюме . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
14 Объектно-ориентированное программирование 101
14.1 self . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
14.2 Классы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
14.3 Методыобъектов . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
14.4 Метод __init__ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
14.5 Переменныеклассаиобъекта . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104
14.6 Наследование . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108
iii
14.7 Метаклассы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
14.8 Резюме . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
15 Ввод-вывод 113
15.1 Вводотпользователя . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
15.2 Файлы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
15.3 Pickle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
15.4 Резюме . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
16 Исключения 119
16.1 Ошибки . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
16.2 Исключения . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
16.3 Обработкаисключений . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
16.4 Вызовисключения . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
16.5 Try..Finally . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122
16.6 Операторwith . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
16.7 Резюме . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
17 Стандартная библиотека 125
17.1 Модульsys . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
17.2 Модульlogging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
17.3 Серия«Модульнедели» . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
17.4 Резюме . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
18 Дополнительно 129
18.1 Передачакортежей . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
18.2 Специальныеметоды . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
18.3 Блокиводновыражение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
18.4 Lambda-формы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
18.5 Генераторысписков . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
18.6 Передачакортежейисловарейвфункции . . . . . . . . . . . . . . . . . . . . 132
18.7 execиeval . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
18.8 Операторassert . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
18.9 Функцияrepr . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
18.10 Управляющиепоследовательности . . . . . . . . . . . . . . . . . . . . . . . . 134
18.11 Необрабатываемыестроки . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
18.12 Резюме . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
19 Что дальше 137
19.1 Упражнения . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
19.2 Примерыпрограмм . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
19.3 Вопросыиответы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
19.4 Советыирекомендации . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
19.5 Учебники . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
19.6 Видео . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
iv
19.7 Обсуждение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
19.8 Новости . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
19.9 Установкабиблиотек . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
19.10 Графическиепрограммы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
19.11 РезюмепоинструментамГИП . . . . . . . . . . . . . . . . . . . . . . . . . . . 140
19.12 Различныереализации . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
19.13 Функциональноепрограммирование(дляхорошоподготовленныхчита-
телей). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
19.14 Резюме . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142
20 Приложение: FLOSS 143
20.1 Free/LibreandOpenSourceSoware(FLOSS) . . . . . . . . . . . . . . . . . . . 143
21 Приложение: о книге 145
21.1 Колофон . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
21.2 Обавторе . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146
22 Приложение: История версий 147
23 Приложение: Инструкция по переводу 151
v
vi
Обложка
1.1«Укус Питона» – «A Byte of Python» по-русски
Примечание: Отавтораперевода
Передвамипереводпопулярнойкниги «A Byte of Python»1нарусскийязык.
Авторкниги– Swaroop Chitlur .
Авторрусскогоперевода– Владимир Смоляр2
Настоящийпереводоснованнаверсии2.0оригинальнойкнигииимеетверсию 2.01
Свежуюверсиюоригиналакнигиможнопросмотреть здесь.
«A Byte of Python» – это свободная книга по программированию на языке Python. Она
можетслужитьучебнымпособиемилируководствомпоязыкуPythonдляначинающей
аудитории.Есливашизнанияокомпьютереограничиваютсятем,каксохранятьтексто-
выефайлы,этакнигадлявас.
Настоящая книга описывает язык Python 3, несмотря на то, что Python 2 всё ещё более
распространён(болеедетальнообэтомсм.раздел Python 2 против 3 ).
1.2Кто читает «A Byte of Python»?
Вотчтолюдиговорятонастоящейкниге:
«Лучшее, что мне удалось найти – “A Byte of Python” – просто блестящая книга для на-
чинающих. Она хорошо написана, основные понятия доступно объясняются на наглядных
примерах.»
–SyedTalal(19лет)
1Названиекниги«AByteofPython»(дословно–«БайтПитона»)по-английскизвучиттакже,каки«A
BiteofPython»–«УкусПитона»( прим.перев. )
2Сообщения об ошибках и предложения по улучшению перевода просьба присылать на e-mail:
v_2e@ukr.net
1
A Byte of Python (Russian), Версия 2.01
«Это лучший учебник для начинающих из всех, что я видел! Спасибо вам за ваш труд.»
–WaltMichalik(wmich50-at-theramp-dot-net)
«Вы написали лучший учебник по Python из тех, что я встречал в Сети. Отличная работа.
Спасибо!»
–JoshuaRobin(joshrob-at-poczta-dot-onet-dot-pl)
«Превосходный вводный курс в программирование #Python для начинающих»
–ShanRajasekaran
«Привет! Я из Доминиканской Республики. Меня зовут Павел. Недавно я прочитал вашу кни-
гу “A Byte of Python”, и нахожу её замечательной :). Я многому научился на приведённых при-
мерах. Ваша книга – отличный помощник таким новичкам, как я…»
–PavelSimo(pavel-dot-simo-at-gmail-dot-com)
«Недавно я закончил читать “A Byte of Python” и подумал, что я обязательно должен побла-
годарить вас. Было грустно дойти до последних страниц, так как это означало возвращение
к тупым и скучным руководствам O’Reilly или чего-то подобного для изучения Python. В лю-
бом случае я очень благодарен вам за вашу книгу.»
–SamuelYoung(sy-one-three-seven-at-gmail-dot-com)
«Уважаемый Swaroop, я прохожу курс, который ведёт преподаватель, совсем не заинтересо-
ванный в преподавании. Мы пользуемся книгой “Изучаем Python”, второе издание O’Reilly. Но
она совсем не для начинающих студентов, практически без каких-либо знаний о программи-
ровании, и преподавателя, который должен работать кем-нибудь другим. Огромное спасибо
вам за вашу книгу. Без неё я так бы никогда ничего и не понял о Python и программировании
вообще. Тысяча благодарностей! Вы умеете “разбить мысль на части” до такого уровня,
чтобы начинающим было легко понять, а далеко не каждый на это способен.»
–JosephDuarte(jduarte1-at-cﬂ-dot-rr-dot-com)
«Я в восторге от вашей книги! Это самый лучший учебник по Python, кроме того полезный
и как справочник. Просто блестяще! Настоящий шедевр! Так держать!»
–Chris-AndréSommerseth
2 Глава 1. Обложка
A Byte of Python (Russian), Версия 2.01
«Пишу вам, чтобы поблагодарить за написание и публикацию в сети “A Byte of Python”. Я
предпринимал попытки изучить Python в течение нескольких месяцев, прежде чем наткнул-
ся на вашу книгу. И хотя я достиг небольших успехов с pyGame, мне никак не удавалось за-
кончить программу.
Благодаря вашему упрощению многих понятий, Python теперь кажется мне вполне дости-
жимой целью. Кажется, теперь я наконец-то освоил основы и могу продолжать идти к своей
настоящей цели – разработке игр.
…
Ещё раз спасибо ОГРОМНОЕ за размещение такого структурированного и полезного путе-
водителя по основам программирования в Интернете. Он провёл меня через ООП, разъяснив
то, что не смогли разъяснить два учебника.»
–MaGallivan(m-underscore-gallivan12-at-hotmail-dot-com)
«Я бы хотел поблагодарить вас за вашу книгу “A byte of python”, которая кажется мне са-
мым лучшим средством для изучения Python. Мне 15 лет, я живу в Египте. Зовут меня Ах-
мед. Python – мой второй язык программирования. В школе я изучал Visual Basic 6, но мне
он не понравился, а изучать Python мне по-настоящему нравится. Мне удалось написать
программу “Адресная книга”. Теперь я буду больше программировать сам и читать чужие
программы на Python (если вы подскажете мне подходящий их источник). Также я намерен
приступить к изучению Java, и если бы вы могли порекомендовать мне пособие по Java, столь
же хорошее, как ваше, это бы мне очень помогло. Спасибо.»
–AhmedMohammed(sedo-underscore-91-at-hotmail-dot-com)
«Замечательным источником для начинающих, желающих узнать больше о Python может
послужить пособие “A Byte of Python”, написанное Swaroop C H в 110 страницах. Оно отлич-
но написано, легко воспринимается и, возможно, это лучшее из существующих введение в
программирование на Python»
–DrewAmesвстатье“ScriptingScribus”,опубликованнойнаLinux.com
«Вчера я прошёл почти весь “Byte of Python” на своём Nokia N800, и он показался мне наиболее
лёгким и лаконичным введением в Python из всех, что я встречал. Настоятельно рекомендую
его как отправную точку для изучающих Python.»
–JasonDelportвсвоёмблоге
«“Byte of Vim и Python”, написанные @swaroopch, на мой взгляд, наилучшие образцы техни-
ческой документации. Прекрасно читаются #FeelGoodFactor »
–SurendranговоритвТвиттере
1.2. Кто читает «A Byte of Python»? 3
A Byte of Python (Russian), Версия 2.01
«”Byte of python” – безусловно лучший»
(в ответ на вопрос «Посоветуйте хороший и недорогой ресурс для изучения основ Python.»)
–JustinLoveTrueпишетнастраницеFacebook
«Книга “Byte of Python” очень помогла. Спасибо, bigtime :) »
–Chinmay
«Всегда был поклонником “A Byte of Python” – написанного как для новичков, так и для опыт-
ных программистов.»
–PatrickHarrington,вответенаStackOverﬂow
Даже NASA
ЭтакнигаиспользуетсядажевНАСА!Еюпользуютсявлабораторииреактив-
ногодвижения3врамкахпроекта«Сетьдальнейкосмическойсвязи»4.
Учебные курсы
Этакнигаиспользуетсявкачествеучебногоматериалавразличныхучебных
заведениях
•Курс«Принципыязыковпрограммирования»вуниверситетеVrije,Ам-
стердам
•Курс«Основымашинныхвычислений»вКалифорнийскомУниверсите-
тевДэвисе
•Курс«ПрограммированиенаPython»вГарвардскомуниверситете
•Курс«Введениевпрограммирование»вУниверситетеЛидса
•Курс«Введениевразработкуприложений»вБостонскомУниверситете
•Курс«Методыинформационныхтехнологийвметеорологии»вУнивер-
ситетеОклахомы
•Курс«Обработкагеоданных»вУниверситетештатаМичиган
•Курс«Многоагентныесистемысемантическойпаутины»вУниверситете
Эдинбурга
3JetPropulsionLaboratory (прим.перев. )
4DeepSpaceNetwork (прим.перев. )
4 Глава 1. Обложка
A Byte of Python (Russian), Версия 2.01
1.3Лицензия
Настоящаякнигараспространяетсянаусловияхлицензии CreativeCommonsAribution-
ShareAlike3.0Unported .
Этоозначает,что:
•Выимеетеправокопировать,распространятьипередаватьеёдругим
•Выимеетеправоиспользоватьфрагментыэтойкнигивсвоихтекстах
•Выимеетеправоиспользоватьеёвкоммерческихцелях
Внимание:
•При продаже электронной или печатной версии этой книги в её описании необ-
ходимовявной форме указать,чтоонараспространяется неотимениеёпервона-
чальногоавтора.
•Во введении или на титульной странице должно быть указано первичное автор-
ство в форме ссылки на страницу hp://www.swaroopch.com/notes/Python с ясным
указаниемнато,чтоисходныйтексткнигиможетбытьнайденпоэтомуадресу.
•Все фрагменты программ/сценарии, представленные в этой книге, распространя-
ютсянаусловияхМодифицированнойлицензииBSD5,еслиявнонеуказанообрат-
ное.
1.4Читать
Выможете приступитькчтению книгивбраузерепрямосейчас.
1.5Купить книгу
Чтобы иметь возможность почитать эту книгу без подключения к Интернету, а также
поддержатьеёдальнейшуюразработкуиусовершенствование,выможете купитьеёпе-
чатныйвариант (наанглийскомязыке).
1.6Скачать
•ВвидеPDF-файла
•ВформатеEPUB(готовитсяквыпускупопросьбамчитателей).
•Полныйисходник
Если вы хотите поддержать продолжение разработки этой книги, купитееёпечатную
копию .
53-clauseBSDlicense (прим.перев. )
1.3. Лицензия 5
A Byte of Python (Russian), Версия 2.01
1.7Книга на вашем родном языке
Есливыхотитепочитатьэтукнигуилипомочьперевестиеёнадругиеязыки,перейдите
настраницу Переводы.
6 Глава 1. Обложка
Переводы
Благодарямногимнеутомимымдобровольцам,Существуетмногопереводовэтойкниги
наразныеестественныеязыки.
Есливыхотитепомочьспереводом,просмотритесписокволонтёровдлясоответствую-
щихязыковвнизуирешите,стоитливамначатьновыйпереводилипомочьужесуще-
ствующемупроекту.
Есливырешилиначатьновыйперевод,прочитайте,пожалуйста, инструкцию по перево-
ду.
2.1Доступные переводы
2.1.1 Арабский
Нижеприведенассылканаарабскуюверсию.Благодарность Ashraf Ali Khalaf заперевод
книги. Вы можете прочитать всю книгу в Интернете по этому адресу или скачать её с
sourceforge.net .Подробнеесм. здесь.
2.1.2 Бразильский португальский
Существуетдваперевода:
SamuelDiasNeto (samuel.arataca-at-gmail-dot-com)осуществилпервыйперевод
этойкнигинабразильскийпортугальскийдляверсииPython2.3.5.
ПереводSamuel’ядоступеннастранице aprendendopython .
RodrigoAmaral (rodrigoamaral-at-gmail-dot-com)принялсязапереводкнигина
бразильскийпортугальский.
ПереводRodrigoдоступенна этойстранице .
2.1.3 Каталонский
Moises Gomez (moisesgomezgiron-at-gmail-dot-com) приступил к переводу книги на ката-
лонскийязык.Переводнаходитсявпроцессе,ибылдоступеннастраницах erstwhilewiki .
Moisès Gómez :
7
A Byte of Python (Russian), Версия 2.01
«Я разработчик и преподаватель программирования (обычно для людей без
предварительнойподготовки).
НекотороевремяназадмнепонадобилосьизучитьPython,икнигаSwaroop’а
оченьпомогламне.Просто,понятноидостаточнополно.Какразто,чтомне
былонужно.
Послеэтогояподумал,чтотакаякнигаможетпригодитьсяидругимлюдямв
моейстране.Ноанглийскийязыкможетстатьпреградойдлянекоторых.
Так почему бы мне не перевести её? И я сделал это для предыдущей версии
книги.
Вмоейстранедвагосударственныхязыка.Явыбралкаталонский,таккакпо-
думал,чтонаболеераспространённыйиспанскийеёнавернякапереведёткто-
нибудьдругой.»
2.1.4 Китайский
Китайскуюверсиюможнонайтина этойстранице .
Juan Shen (orion-underscore-val-at-163-dot-com)приступилкпереводукнигинакитайский
язык.
Онадоступнапо этомуадресу .
«ЯаспирантотделабеспроводныхтелекоммуникацийвПекинскомтехноло-
гическом университете, Китай. В настоящее время я занимаюсь исследова-
ниемсинхронизации,регулировкиканалапередачиданныхимногопользо-
вательским определением системы с многими несущими частотами CDMA.
Python является моим основным языком программирования для ежедневно-
го моделирования и расчётов. По большей части, с использованием Python
Numeric. Я познакомился с Python всего пол года назад, но как вы могли ви-
деть,этодействительнооченьлёгкийдляпониманияиосвоенияязык,ивме-
сте с тем, очень эффективный. Как и предупреждал в своей книге Swaroop,
“Теперьэтомойлюбимыйязыкпрограммирования”.
“A Byte of Python” был моим учебником по Python. Он просто и эффектив-
но вводит вас в мир Python в кратчайшие сроки. Он не слишком длинный,
но покрывает практически все важные темы о Python. Я считаю, “A Byte of
Python” нужно всегда рекомендовать новичкам в качестве первого учебника.
Я посвящаю свой перевод миллионам потенциальных пользователей Python
вКитае.»
2.1.5 Традиционный китайский
Fred Lin(gasolin-at-gmail-dot-com)приступилкпереводукнигинатрадиционныйкитай-
скийязык.
Онадоступнапоадресу hp://code.google.com/p/zhpy/wiki/ByteOfZhpy .
8 Глава 2. Переводы
A Byte of Python (Russian), Версия 2.01
Любопытнойособенностьюэтогопереводаявляетсято,чтоонсодержитисходныетексты
накитайском Python нарядусоригинальнымитекстаминаPython.
Fred Lin:
«ЯработаюинженеромпрограммногообеспечениясетевыхустройстввDelta
Network.Крометого,яучастникразработкивеб-инструментарияTurboGears.
Как евангелист Python (:-p) я нуждаюсь в некотором материале, опираясь на
который я смогу популяризовать язык Python. Я обнаружил, что “A Byte of
Python” нашёл золотую середину между книгами для новичков и для опыт-
ных программистов. “A Byte of Python” подробно излагает основы Python в
разумныхобъёмах.
Мой перевод поначалу основывался на версии на упрощённом китайском
языке, но со временем в него было внесено множество изменений для под-
держанияеговсоответствиистекущимиверсиямикниги.»
Последние версии перевода на традиционный китайский также отличаются
наличиемисходныхкодовпрограммнакитайскомPython,благодаряпроекту
“zhpy”,существующемусавгуста2007года.
zhpy(произноситсякак“Зэд.Аш.Пи”или“зиппи”)являетсяэдакойнадстрой-
койнадPython,переводящейPythonнатрадиционныйилиупрощённыйки-
тайский.Этотпроектсуществует,преждевсего,вобразовательныхцелях.
2.1.6 Французский
Gregory(coulix-at-ozforces-dot-com-dot-au)началпереводкнигинафранцузскийязык.
Gérard Labadie (Palmipede)закончилпереводкниги.Онадоступнана этойстранице .
2.1.7 Немецкий
Lutz Horn (lutz-dot-horn-at-gmx-dot-de), Bernd Hengelein (bernd-dot-hengelein-at-gmail-dot-
com)и Christoph Zwerske (cito-at-online-dot-de)началипереводнанемецкийязык.
Ихпереводнаходитсяна hp://abop-german.berlios.de .
Lutz Horn говорит:
«Мне 32 года, я закончил математический факультет Гейдельбергского уни-
верситета в Германии. В настоящее время я работаю программистом в обще-
ственномпроектепосозданиювеб-порталакомпьютерныхнауквГермании.
Основной язык, который я использую на работе, – Java, но “за кулисами” я
стараюсь делать как можно больше на Python. Особенно легко удаётся про-
изводить анализ текста и конвертацию на Python. Я не очень знаком с ин-
струментариямидляграфическогоинтерфейса,таккакпобольшейчастиза-
нимаюсьвеб-программированием,гдеинтерфейспользователяформируется
такимиJava-инструментамикакStruts.Внастоящеевремяястараюсьбольше
2.1. Доступные переводы 9
A Byte of Python (Russian), Версия 2.01
применять функциональное программирование и генераторы. После корот-
кого взгляда на Ruby я был впечатлён использованием блоков в этом языке.
Мнетакженравитсядинамическаяприродатакихязыков,какPythonиRuby,
посколькуэтодаётмневозможностьделатьто,чтоневозможносделатьвбо-
лее статических языках, как Java. Я стал искать какой-нибудь вводный курс
в программирование, подходящий для полного не-программиста. Я нашёл
книги“HowtoinkLikeaComputerScientist:LearningwithPython”и“Diveinto
Python”.Перваякнигахорошадляновичков,нослишкомдлиннадляперево-
да.Втораянеподходитдляновичков.Авот“AByteofPython”,какмнекажется,
попадаеткакразмеждуэтимидвумя,таккакнеслишкомдлинна,написана
посуществу,новместестем,достаточноподробнадляобученияновичка.По-
мимо этого, мне понравилась простая структура DocBook, которая позволяет
переводить текст, а также генерировать результирующий текст в различных
форматахкакповолшебству.»
Bernd Hengelein говорит:
«Мы с Лутцем собираемся переводить книгу на немецкий язык вместе. Мы
началисВведенияиПредисловия,номыбудеминформироватьваспомере
продвижения.
Теперь пару слов о себе. Мне 34 года, и я играюсь с компьютерами с 1980-х,
когда“CommodoreC64”повелевалдетскимикомнатами.Послетого,какяпо-
лучилобразованиевобластикомпьютерныхнаук,яначалработатьпрограм-
мистом.Внастоящеевремяяработаювобластимедицинскойвизуализации
в одной из крупнейших немецких компаний. И хотя основным языком, ко-
торым я (вынужденно) пользуюсь на работе, является C++, я постоянно ищу
новые пространства для освоения. В прошлом году я влюбился в чудесный
языкPythonодновременнозаеговозможностиикрасоту.Где-товИнтернете
ячиталочеловеке,которыйсказал,чтоемунравитсяPython,потомучтопро-
граммынанёмвыглядяткрасиво.Намойвзгляд,онсовершенноправ.Когда
я начинал изучать Python, я заметил, что хорошей документации на немец-
комязыкепонемубылооченьмало.Когдажеянаткнулсянавашукнигу,мне
в голову пришла внезапная идея перевести её на немецкий. К счастью, ана-
логичная идея пришла в голову и Лутцу, благодаря чему теперь мы можем
разделитьработу.Снетерпениемждупродуктивногосотрудничества!»
2.1.8 Греческий
Греческое сообщество Ubuntu перевело книгу на греческий язык ), для использования
в уроках Python на своём форуме. Для более подробной информации свяжитесь с
@savvasradevic .
10 Глава 2. Переводы
A Byte of Python (Russian), Версия 2.01
2.1.9 Индонезийский
Daniel(daniel-dot-mirror-at-gmail-dot-com) переводит книгу на индонезийский язык на
hp://python.or.id/moin.cgi/ByteofPython .
W. Priyambodo такжеизъявилжеланиеперевестикнигунаиндонезийский.Переводна-
ходитсявпроцессенастранице hp://www.swaroopch.org/notes/Python_id:Daar_Isi .
2.1.10 Итальянский
Enrico Morelli (mr-dot-mlucci-at-gmail-dot-com) и Massimo Lucci (morelli-at-cerm-dot-uniﬁ-
dot-it)взялисьзапереводкнигинаитальянскийязык.
Итальянскийпереводрасположеннаwww.gentoo.it/Programmazione/byteofpython.Новый
переводнаходитсявпроцессездесь: hp://www.swaroopch.org/notes/Python_it:Prefazione .
Massimo Lucci иEnrico Morelli :
«Мы работаем в университете Флоренции (Италия) – на факультете хи-
мии. Я (Massimo) в качестве инженера и системного администратора ЯМР-
спектрометров,аEnrico–вкачествеинженераисистемногоадминистратора
параллельных/кластерныхсистем.МыпрограммируемнаPythonужеоколо
семи лет, а на платформах Linux мы работаем уже около десяти лет. Мы ад-
министрируемвеб-страницуwww.gentoo.itдлядистрибутиваGentoo/Linux,а
также страницу www.nmr.it (в данный момент в разработке) о приложениях
ииспользованииядерногомагнитногорезонанса.Вотивсё!Нанаспроизвёл
впечатлениетотживойязык,которымнаписанаэтакнига,имысчитаем,что
этооченьважнодляпредставленияPythonновымпользователям(например,
сотнямстудентовиисследователейизнашихлабораторий).»
2.1.11 Японский
Японскаяверсиянаходится здесь.
Shunro Dozono (dozono-at-gmail-dot-com)переводиткнигунаяпонскийязык.
2.1.12 Монгольский
Ariunsanaa Tunjin (luballons2010-at-gmail-dot-com) принялся за перевод книги на мон-
гольскийязык.
Обновление от 22 ноября 2009г :Ariunsanaa награнизавершенияперевода.
2.1.13 Норвежский (bokmål)
Eirik Vågeskar –студент Sandvikavideregåendeskole вНорвегии, блоггер,ивданныймо-
мент переводит книгу на норвежский язык (bokmål). Перевод находится в процессе. Вы
можетевзглянутьнанего здесь.
2.1. Доступные переводы 11
A Byte of Python (Russian), Версия 2.01
Eirik Vågeskar :
«Я всегда хотел программировать, но поскольку я разговариваю на малорас-
пространённомязыке,процессобучениябылвсегдазатруднён.Большинство
пособий и книг написано на техническом английском языке, так что боль-
шинствовыпускниковшколыдаженеобладаютдостаточнымсловарнымза-
пасом, чтобы понять, о чём идёт речь. Но как только я нашёл эту книгу, мои
проблемы сразу разрешились. “A Byte of Python” простым нетехническим
языком объясняет язык программирования, который так же прост, и это де-
лает изучение Python увлекательным. После прочтения половины книги, я
понял, что её стоит перевести. Я надеюсь, что перевод поможет людям, ока-
завшимсявпохожейситуации(особенно,молодым),аможетбытьдажеивы-
зоветинтерескязыкусредилюдейсменьшимитехническимизнаниями.»
2.1.14 Польский
Dominik Kozaczko (dkozaczko-at-gmail-dot-com)приступилкпереводукнигинапольский.
Переводнаходитсявпроцессе,иегоглавнаястраницарасположеназдесь: UkąśPythona .
Обновление : По состоянию на 2 октября 2009г. перевод завершён. Благодарности Доми-
нику,двумегостудентамиихдругузапотраченноевремяиусилия!
Dominik Kozaczko: «Я преподаватель компьютерных наук и информационных техноло-
гий.»
2.1.15 Португальский
Fidel Viegas (ﬁdel-dot-viegas-at-gmail-dot-com) взялся за перевод книги на португальский
язык.
2.1.16 Румынский
Paul-Sebastian Manole (brokenthorn-at-gmail-dot-com)началпереводкнигинарумынский
язык.
Paul-Sebastian Manole :
«ЯстудентвторогокурсафакультетакомпьютерныхнауквуниверситетеSpiru
Haret University, в Румынии. Хотя, я больше программист-самоучка и решил
изучить новый язык – Python. Из Интернета я узнал, что нет лучшего пути
для этого, чем книга “A Byte of Python”. Вот насколько популярна эта книга
(поздравляюеёавторастем,чтоемуудалосьнаписатьтакуюлёгкуюдлявос-
приятия книгу). Мне начал нравиться Python, и я решил помочь переводом
последнейверсиикнигиSwaroop’анарумынскийязык.Ихотяяимогуока-
заться первым с такой инициативой, если у вас есть желание помочь мне,
присоединяйтесь.»
Переводпроизводитсяна hp://www.swaroopch.org/notes/Python_ro .
12 Глава 2. Переводы
A Byte of Python (Russian), Версия 2.01
2.1.17 Русский
Владимир Смоляр (v_2e-at-ukr-dot-net)перевёлкнигунарусскийязык.Текущуюверсию
переводаможнонайтина hp://wombat.org.ua/AByteOfPython .
2.1.18 Украинский
Averkiev Andrey (averkiyev-at-ukr-dot-net) взялся за перевод книги на украинский язык
(насколькопозволяетвремя).
2.1.19 Словацкий
Albertio Ward (albertioward-at-gmail-dot-com) перевёлкнигунасловацкийязык :
«Мыявляемсянекоммерческойорганизациейподназванием“Переводыдля
обучения”. Мы представляем собой группу людей, преимущественно, сту-
дентов и преподавателей Славянского университета. Среди нас есть студен-
ты разных факультетов: лингвистики, химии, биологии и т.д. Мы стараемся
отыскивать в Интернете интересные публикации, полезные для нас или на-
шихколлег.Иногдамысаминаходимстатьи,аиногданашипреподаватели
помогают нам подобрать материал для перевода. После получения разреше-
нияавторовстатьимыпереводимстатьиипубликуемихвнашемблоге,до-
ступномнашимколлегамидрузьям.Такиепереводычастобываютполезны
студентамприобучении.
Почему я выбрал именно вашу книгу для перевода? Я сделал это для того,
чтобыпомочьболгарампонятькнигувдеталях.Оценивновизнуиважность
обсуждаемых в книге тем, я понял, что она весьма актуальна для населения
моейстраны.Поэтомуядумаю,онабудетпопулярна.Ивданномслучаебудет
отсутствоватьязыковойбарьер,таккаконустранёнмоимпереводом.»
2.1.20 Испанский
Alfonso de la Guarda Reyes (alfonsodg-at-ictechperu-dot-net), Gustavo Eeverria (gustavo-
dot-echeverria-at-gmail-dot-com), David Crespo Arroyo (davidcrespoarroyo-at-hotmail-dot-
com) и Cristian Bermudez Serna (crisbermud-at-hotmail-dot-com) приступили к переводу
книги на испанский язык. Перевод находится в процессе. Вы можете читать испанский
(аргентинский)переводна этойстранице .
Gustavo Eeverria говорит:
«ЯработаюпрограммистомвАргентине.Побольшейчастияиспользуютех-
нологии C# и .NET на работе, но для моих собственных проектов – только
Python и Ruby. Я узнал о Python довольно давно, и сразу же остановился на
нём. Вскоре после моего знакомства с Python я обнаружил эту книгу, и она
2.1. Доступные переводы 13
A Byte of Python (Russian), Версия 2.01
помогла мне в изучении этого языка. Тогда я решил перевести её на испан-
ский язык. Теперь, после нескольких обращений я начал переводить “A Byte
ofPython”вместесMaximilianoSoler.»
Cristian Bermudez Serna говорит:
«Я студент факультета телекоммуникаций в университете Antioquia (Колум-
бия). Несколько месяцев назад я решил изучать Python и обнаружил эту за-
мечательнуюкнигу,послечегорешилподключитьсякеёпереводунаиспан-
скийязык.»
2.1.21 Шведский
Mikael Jacobsson (leochingkwake-at-gmail-dot-com) решил перевести эту книгу на швед-
скийязык.
2.1.22 Турецкий
Türker SEZER (tsezer-at-burk-dot-net) и Bugra Cakir (bugracakir-at-gmail-dot-com) начали
переводкнигинатурецкийязык.Гдетурецкаяверсия?Bitsedeokusak.
Примечание: Замените -at-на@,-dot-на.и-underscore- на_вадресахэлектронной
почты,указанныхнаэтойстранице.Дефисывовсехостальныхместахадресаоставьтекак
есть.
14 Глава 2. Переводы
Предисловие
Python–это,пожалуй,одинизнемногихязыковпрограммирования,простыхвосвоении
и одновременно мощных. Это очень важно и для начинающих, и для специалистов, но
чтоещёважнее–нанёмприятнопрограммировать.Настоящаякнигапризванапомочь
вам в изучении этого замечательного языка и показать, как можно быстро и безболез-
ненноделатьмногиевещи–всущности,этотакоесебе«Идеальноепротивоядиепротив
всехвашихпроблемвпрограммировании».
3.1Для кого эта книга
Этакнигаслужитпутеводителемилиучебнымпособиемдляизученияязыкапрограм-
мированияPython.Онанацелена,преимущественно,нановичков.Темнеменее,онабу-
детполезнаиопытнымпрограммистам.
Идеятакова,чтоесливсё,чтовызнаетеокомпьютерах,этокаксохранятьтекстовыефай-
лы, вы можете изучить Python по этой книге. Если у вас имеется некоторый предвари-
тельныйопытвпрограммировании,вывсёравноможетеизучитьPythonпоэтойкниге.
Еслиувастакиимеетсяпредварительныйопытпрограммирования,васнаверняказаин-
тересуют различия между Python и вашим любимым языком программирования, мно-
гиеизкоторыхспециальновыделенывтексте.Однако,считаюсвоимдолгомпредупре-
дитьвасотом,чтовскоревашимлюбимымязыкомпрограммированиявсёравностанет
Python!
3.2Немного истории
Впервыеяобратилсяк Python,когдамне понадобилосьнаписатьустановщикдлясвоей
программы «Diamond», чтобы упростить процесс установки. Мне пришлось выбирать
между привязками Python и Perl к библиотеке Qt. Я поискал информацию в сети на эту
тему и наткнулся на статью Эрика С. Реймонда , известного и уважаемого хакера, в ко-
торойонрассказываетотом,какPythonсталеголюбимымязыкомпрограммирования.
Также я выяснил, что привязки PyQt были более зрелыми по сравнению с Perl-Qt. Так я
определилсясвыборомвпользуPython.
После этого я начал искать хорошую книгу по Python. И не нашёл! Конечно, я нашёл
несколько книг O’Reilly, но они были либо слишком дорогими, либо больше походили
15
A Byte of Python (Russian), Версия 2.01
насправочник,нежелинаучебник.Такчтомнепришлосьдовольствоватьсядокумента-
цией, поставляемой в комплекте с Python. Но она оказалась слишком краткой и непол-
ной.Безусловно,онадаламненекотороепредставлениеотом,чтотакоеPython,ноэтого
былоявнонедостаточно.Мнееёхватало,посколькуяимелпредыдущийопытпрограм-
мирования,ноонаникоимобразомнеподходиладляновичков.
ПримерночерезполгодапослемоихпервыхшаговвPythonяустановилпоследнюю(на
тотмомент)версиюRedHatLinux9.0иначалигратьсясKWord.Ябылввосторгеотнего,
ивдругмнепришловголовунаписатьвнёмнекоторыемыслиоPython.Ярассчитывал
написатьнесколькостраниц,нообъёмбыстровыросдо30страниц.Тогдаярешилвсерьёз
придатьэтомутекстуформукниги.После множества переписыванийонадостиглатого
состояния, в котором она уже могла служить полезным пособием по изучению языка
Python.ЯсмотрюнасвоюкнигукакнасвойвкладиданьсообществусвободногоПО.
Эта книга была начата как мои личные заметки о Python, и я до сих пор смотрю на неё
также,хотяиприложилнемалоусилийктому,чтобысделатьеёболееподходящейдля
других:)
И конечно, в духе свободного ПО, я получил множество конструктивных предложений,
критикии отзывовотчитателей,которыепомоглимнезначительноулучитькнигу.
3.3Состояние книги
Воктябре2012годабыливнесенынекоторыеисправления,обновления,атакжепопрось-
бамнесколькихпользователейстраницыэтойкнигибылипереформатированыприпо-
мощи Pandoc для того, чтобы сделать возможным автоматическое генерирование элек-
тронныхкнигнаихоснове.
Вредакциизадекабрь2008года(посравнениюспредыдущимсерьёзнымпересмотром
вмарте2005года)былидобавленысведения,связанныесвыходомPython3.0.
Эта книга нуждается в помощи своих читателей по обнаружению не очень хорошо, не
оченьпонятноилипопростуневернонаписанныхчастей.Еслиувасестьтакиепредло-
жения,пожалуйста,обращайтесь ксамомуавторукниги или к автору перевода ,который
вычитаете.
3.4Официальная веб-страница
Официальнаястраницаэтойкнигинаходитсяпоадресу hp://www.swaroopch.com/notes/Python ,
гдевыможетепрочитатьсамукнигу,скачатьеёпоследнююверсию, купитьеёпечатный
вариантиоставитьсвоиотзывы.
16 Глава 3. Предисловие
A Byte of Python (Russian), Версия 2.01
3.5К размышлению
«Существуетдваспособасоставленияпрограмм:первыйсостоитвтом,чтобы
сделать её настолько простой, чтобы в ней явно не было ошибок; второй – в
том, чтобы сделать её настолько сложной, чтобы в ней не было явных оши-
бок.»
–C.A.R.Hoare
«Успехвжизни–нестольковопросталантаивозможностей,сколькоконцен-
трацииинастойчивости.»
–C.W.Wendte
3.5. К размышлению 17
A Byte of Python (Russian), Версия 2.01
18 Глава 3. Предисловие
Введение
Python–одинизтехредкихязыковпрограммирования,которыеодновременнопретен-
дуют на звание простых имощных. Вас приятно удивит то, как легко можно сосредо-
точиться на решении поставленной задачи, а не на синтаксисе и структуре языка, на
которомвыпрограммируете.
ОфициальноPythonпредставляюттак:
Python – это простой в освоении и мощный язык программирования. Он
предоставляет эффективные высокоуровневые структуры данных, а также
простой,ноэффективныйподходкобъектно-ориентированномупрограмми-
рованию.Егоэлегантныйсинтаксисидинамическаятипизациянарядустем,
чтоонявляетсяинтерпретируемым,делаютегоидеальнымязыкомдлянапи-
саниясценариевибыстройразработкиприложенийвразличныхобластяхи
набольшинствеплатформ.
Вследующемразделемырассмотримэтиособенностиболеедетально.
Историяназвания
Гвидо ван Россум, создатель языка Python, назвал его так в честь телешоу на
BBC под названием «Летающий цирк Монти Пайтона»1, а вовсе не потому,
чтоонлюбитзмей,убивающихживотныхобвиваниемсвоегодлинноготела
вокругнихизадавливанием.
4.1Особенности Python
4.1.1 Простой
Python – простой и минималистичный язык. Чтение хорошей программы на Python
оченьнапоминаетчтениеанглийскоготекста,хотяидостаточнострогого!Такаяпсевдо-
кодоваяприродаPythonявляетсяоднойизегосамыхсильныхсторон.Онапозволяетвам
сосредоточитьсянарешениизадачи,аненасамомязыке.
1«MontyPython’sFlyingCircus»( прим.перев. )
19
A Byte of Python (Russian), Версия 2.01
4.1.2 Лёгкий в освоении
Каквыувидите,наPythonчрезвычайнолегконачатьпрограммировать.Pythonобладает
исключительнопростымсинтаксисом,какужеотмечалосьвыше.
4.1.3 Свободный и открытый
Python – это пример свободного и открытого программного обеспечения – FLOSS
(Free/Libré and Open Source Soware). Проще говоря, вы имеете право свободно распро-
странять копии этого программного обеспечения, читать его исходные тексты, вносить
изменения,атакжеиспользоватьегочастивсвоихпрограммах.ВосновесвободногоПО
лежит идея сообщества, которое делится своими знаниями. Это одна из причин, по ко-
торым Python так хорош: он был создан и постоянно улучшается сообществом, которое
простохочетсделатьеголучше.
4.1.4 Язык высокого уровня
ПринаписаниипрограммынаPythonвамникогданепридётсяотвлекатьсянатакиениз-
коуровневыедетали,какуправлениепамятью,используемойвашейпрограммой,ит.п.
4.1.5 Портируемый
Благодарясвоейоткрытойприроде,Pythonбылпортированнамногоплатформ(т.е.из-
менёнтакимобразом,чтобыработатьнаних).Всевашипрограммысмогутзапускаться
налюбойизэтихплатформбезкаких-либоизменений,еслитольковыизбегалиисполь-
зованиясистемно-зависимыхфункций.
Python можно использовать в GNU/Linux, Windows, FreeBSD, Macintosh, Solaris, OS/2,
Amiga,AROS,AS/400,BeOS,OS/390,z/OS,PalmOS,QNX,VMS,Psion,AcornRISCOS,VxWorks,
PlayStation,SharpZaurus,WindowsCEидаженаPocketPC!
Вы можете даже использовать такую платформу, как Kivyдля создания игр для iOS
(iPhone,iPad)иAndroid.
4.1.6 Интерпретируемый
Этотребуетнекоторогопояснения.
Программа,написаннаянакомпилируемомязыкепрограммирования,какнапример,C
или C++, преобразуется из исходного языка (т.е. C или C++) в язык, понятный компью-
теру (бинарный код, т.е. нули и единицы) при помощи компилятора с применением
разнообразныхфлаговипараметров.Когдавызапускаететакуюпрограмму,компонов-
щик/загрузчиккопируетпрограммусдискавоперативнуюпамятьизапускаетеё.
Pythonже,напротив,нетребуеткомпиляциивбинарныйкод.Программапросто выпол-
няетсяиз исходного текста. Python сам преобразует этот исходный текст в некоторую
20 Глава 4. Введение
A Byte of Python (Russian), Версия 2.01
промежуточную форму, называемую байткодом, а затем переводит его на машинный
языкизапускает.ВсёэтозаметнооблегчаетиспользованиеPython,посколькунетнеоб-
ходимостизаботитьсяокомпиляциипрограммы,подключенииизагрузкенужныхбиб-
лиотекит.д.Вместестем,этоделаетпрограммынаPythonнамногоболеепереносимы-
ми,таккакдостаточноихпростоскопироватьнадругойкомпьютер,иониработают!
4.1.7 Объектно-ориентированный
Python поддерживает как процедурно-ориентированное, так и объектно-
ориентированное программирование. В процедурно-ориентированных языках про-
граммы строятся на основе процедур или функций, которые представляют собой
просто-напросто многократно используемые фрагменты программы. В объектно-
ориентированных языках программирования программы строятся на основе объектов,
объединяющихвсебеданныеифункционал.Pythonпредоставляетпростые,номощные
средствадляООП,особенновсравнениистакимибольшимиязыкамипрограммирова-
ния,какC++илиJava.
4.1.8 Расширяемый
Есливамнужно,чтобынекотораякритическаячастьпрограммыработалаоченьбыстро
или вы вынуждены скрыть часть алгоритма, вы можете написать эту часть программы
наCилиC++,азатемвызыватьеёизпрограммынаPython.
4.1.9 Встраиваемый
PythonможновстраиватьвпрограммынаC/C++,чтобыпредоставлятьвозможностина-
писаниясценариевихпользователям.
4.1.10 Обширные библиотеки
Стандартная библиотека Python просто огромна. Она может помочь в решении самых
разнообразных задач, связанных с использованием регулярных выражений, генериро-
ванием документации, проверкой блоков кода, распараллеливанием процессов, база-
миданных,веб-браузерами,CGI,FTP,электроннойпочтой,XML,XML-RPC,HTML,WAV
файлами, криптографией, GUI (графическим интерфейсом пользователя) и другими
системно-зависимымивещами.Помните,чтовсёэтодоступноабсолютновезде,гдеуста-
новленPython.ВэтомзаключаетсяфилософияPython“Всёвключено”.
Кроместандартнойбиблиотеки,существуетмножестводругихвысококачественныхбиб-
лиотек,которыеможнонайтив КаталогепакетовPython
Резюме
4.1. Особенности Python 21
A Byte of Python (Russian), Версия 2.01
Python–оченьувлекательныйимощныйязык.Онимеетхорошеесоотноше-
ниепроизводительностиивозможностей,чтоделаетнаписаниепрограммна
нёмодновременноинтереснымилёгким.
4.2Python 2 против 3
Если вас не интересует разница между Python 2 и Python 3, вы можете пропустить этот
радел.Новлюбомслучаепомните,какуюверсиювыиспользуете.
В2008годуэтакнигабылапереписанадляPython3.Этобылаоднаизпервыхкниг,по-
свящённыхPython3.Однако,ксожалению,этопривелокпутаницесредипользователей,
пытавшихсяизучатьPython2поверсиикнигидляPython3инаоборот.Темнеменее,мир
понемногумигрируетнаPython3.
Такчтода,вэтойкнигевыбудетеучитьсяпрограммироватьнаPython3,дажеесливко-
нечномсчётепланируетеиспользоватьPython2. Помните, что как только вы как следует
усвоите и научитесь пользоваться любым из них, вы также сможете легко освоить разницу
между ними и адаптироваться. Самое сложное заключается в обучении программированию
и понятии основной части языка Python. Это и будет нашей целью в настоящей книге, а
как только вы её достигнете, вы сможете запросто использовать Python 2 или Python 3 в
зависимости от конкретной ситуации.
Изучить разницу между Python 2 и Python 3 в деталях можно на странице Ubuntu wiki,
посвящённойPython3 .
4.3Что говорят программисты
Интересно,чтотакиевеликиехакеры,какЭрикРэймонд,говорятоPython:
1.Эрик С. Рэймонд – автор работы «Собор и Базар», а также человек, который ввёл
термин“OpenSource”.Онговорит,что Pythonсталеголюбимымязыкомпрограм-
мирования .ЭтастатьяивдохновиламенянапробуперавPython.
2.Брюс Экель – автор знаменитых книг «Думаем на Java» и «Думаем на С++». Он
утверждает,чтонинаодномязыкепрограммированияегоработанебыластольэф-
фективной,какнаPython.Крометого,онсчитает,чтоPython–это,пожалуй,един-
ственный язык, стремящийся облегчить жизнь программисту. Подробнее можно
прочитатьв егополноминтервью .
3.Питер Норвиг –широкоизвестныйавторLisp,атакжедиректорпокачествупоис-
ка в Google (спасибо Гвидо ван Россуму за это замечание). Он говорит, что Python
всегдабылнеотъемлемойчастьюGoogle.Выможетеубедитьсявэтом,заглянувна
страницу GoogleJobs ,накоторойвладениеPythonуказанокактребованиедляраз-
работчиковпрограммногообеспечения.
22 Глава 4. Введение
Установка
Если у вас уже установлен Python 2.x, нет необходимости его удалять для того, чтобы
установитьPython3.0.Обеверсиимогутбытьустановленывсистемеодновременно.
5.1Установка в GNU/Linux и BSD
Если вы используете один из дистрибутивов GNU/Linux, таких как Ubuntu, Fedora,
OpenSUSE,Debian,CentOSили{вашвариант},илиодинизвариантовBSD,какнапример,
FreeBSD,тоскореевсего,ввашейсистемеужеустановленPython.
Чтобы проверить, установлен ли Python на вашей машине с BSD или GNU/Linux, от-
кройтеэмулятортерминала(например, konsoleили gnome-terminal )ивведитекоманду
python -V ,какпоказанониже.
$ python -V
Python 3.3.0
Примечание: $-этоприглашениекоманднойстроки.Ономожетвыглядетьпо-разному
в зависимости от настроек вашей ОС, поэтому я буду обозначать приглашение просто
однимсимволом $.
Есливывидитеинформациюоверсии,какпоказановыше,значитPythonувасужеуста-
новлен.
Еслижевыполучаететакоесообщение:
$ python -V
bash: Python: command not found
значит,Pythonуваснеустановлен.Этомаловероятно,новсёжевозможно.
Примечание: ЕслиувасужеустановленPython3.x,попробуйте python3 -V .
ВэтомслучаеувасбудутдвавариантаустановкиPython:
•СкомпилироватьPythonиз исходныхтекстов иустановитьего.Инструкцияпоком-
пиляцииестьнауказанномвеб-сайте.
23
A Byte of Python (Russian), Версия 2.01
•Установить бинарные пакеты, используя пакетный менеджер, входящий в ком-
плектпоставкивашейОС,какнапример, apt-getвUbuntu/Debianидругихдистри-
бутивах, основанных на Debian, yumв Fedora, pkg_addво FreeBSD, и т.д. Обратите
внимание, что для этого потребуется соединение с Интернетом. В противном слу-
чаевыможетелюбымдругимспособомскопироватьбинарникинасвойкомпьютер
иустановитьоттуда.
5.2Установка в Windows
Посетитестраницу hp://www.python.org/download/ изагрузитепоследнююверсию.Уста-
новкапроизводитсятакже,какидлялюбыхдругихпрограммдляWindows.
Осторожно: Когда вам будет предложено отключить некоторые «опцио-
нальные»компоненты,неотключайтениодного!Некоторыеизэтихком-
понентовмогутвампригодиться,особенноIDLE.
Интересно,чтобольшуючастьзагрузокпроизводятименнопользователиWindows.Ко-
нечно,этонедаётпредставленияополнойкартине,посколькуубольшинствапользова-
телейGNU/LinuxPythonустановленвсистемепоумолчанию.
5.2.1 Командная строка DOS
Для использования Python из командной строки Windows, т.е. приглашения DOS, необ-
ходимоустановитьдолжнымобразомпеременнуюPATH.
Для Windows 2000, XP, 2003 , перейдите в «Панель управления» !«Система» !«До-
полнительно» !«Переменные среды». Нажмите на переменной с именем PATHв от-
деле «Системные переменные», после этого выберите «Редактировать»и допишите
;C:\Python33 к концу того, что там уже есть (проверьте, существует ли такой каталог,
так как для более новых версий Python он будет иметь другое имя). Конечно, укажите
действительноеимякаталога.
ДляболеестарыхверсийWindowsдобавьтеследующуюстрокувфайл C:\AUTOEXEC.BAT :
”PATH=%PATH%;C:\Python33 ”(без кавычек) и перезапустите систему. Для Windows NT ис-
пользуйтефайл AUTOEXEC.NT .
ДляWindowsVista:
1.Нажмитекнопку«Пуск»ивыберите«Панельуправления»
2.Нажмите «Система», справа вы увидите «Просмотр основных сведений о вашем
компьютере». Слева – список действий, последним из которых будет «Дополни-
тельныепараметрысистемы.»Нажмитееё.Отобразитсявкладка«Дополнительно»
диалогапараметровсистемы.Нажмитекнопку“Переменныесреды”справавнизу.
3.В нижнем поле под названием «Системные переменные» прокрутите до Pathи
нажмитекнопку«Редактировать».
24 Глава 5. Установка
A Byte of Python (Russian), Версия 2.01
4.Изменитепуть,какнужно.
5.Перезапуститесистему.Vistaнеобновляетсистемныепутидоперезагрузки.
ДляWindows7:
1.Щёлкните правой кнопкоймыши на значке«Компьютер»нарабочем столеи вы-
берите«Свойства»;иначе–нажмитекнопку«Пуск»ивыберите«ПанельУправле-
ния» !«Система и безопасность» !«Система». Нажмите «Дополнительные па-
раметры системы» слева, а затем выберите вкладку «Дополнительно». Внизу на-
жмитекнопку«Переменныесреды»ивотделе«Системныепеременные»найдите
переменную PATH,выберитееёинажмите»Редактировать».
2.Перейдите к концу строки в поле «Значение переменной» и допишите
;C:\Python33 .
3.Еслизначениепеременнойбыло %SystemRoot%\system32; ,теперьоноприметвид
%SystemRoot%\system32;C:\Python33
4.Нажмите«Ok»,ивсё.Перезагрузканетребуется.
5.2.2 Запуск командной строки Python в Windows
Если вы должным образом установили значение переменной PATH , теперь можно запус-
катьинтерпретаторизкоманднойстроки.
ЧтобыоткрытьтерминалвWindows,нажмитекнопку«Пуск»ивыберите«Выполнить».
Впоявившемсядиалоговомокненаберите cmdинажмите Enter.
Затемнаберите python3 -V ипроверьте,нетлиошибок.
5.3Для пользователей Mac OS X
УпользователейMacOSXPythonужебудетустановленвсистеме.Впротивномслучаевы
можете открыть терминал, нажав Command+Пробел , набрав в открывшейся строке поиска
Terminal инажав Enter.
Затемустановить Homebrew ,выполнив:
ruby -e "$(curl -fsSkL raw.github.com/mxcl/homebrew/go)"
ПослечегоустановитьPython3припомощи:
brew install python3
Атеперьзапустите python3 -V ипроверьте,нетлиошибок.
5.3. Для пользователей Mac OS X 25
A Byte of Python (Russian), Версия 2.01
5.4Резюме
УпользователейсистемGNU/LinuxиBSD,вероятнеевсего,Pythonужеустановлен.Впро-
тивном случае его можно установить, используя пакетный менеджер, поставляемый с
вашимдистрибутивом.ДляWindowsустановкаPythonсводитсякзагрузкеустановщика
и двойному щелчку на нём. С этого момента мы будем считать, что Python 3 в вашей
системеустановлен.
ДалеемыприступимкнаписаниюнашейпервойпрограммынаPython.
26 Глава 5. Установка
Первые шаги
6.1Введение
Давайтепосмотрим,каксоздатьтрадиционнуюпрограмму“HelloWorld”наPython.Это
научитвасписать,сохранятьивыполнятьпрограммынаPython.
Существует два способа запуска программ на Python: использование интерактивного
приглашенияинтерпретатораииспользованиефайластекстомпрограммы.Сейчасмы
увидим,какпользоватьсяобоимиметодами.
6.2Использование командной строки интерпрета-
тора
Откройте окно терминала (как было описано в главе Установка ) и запустите интерпре-
таторPython,введякоманду python3инажав Enter.
Пользователи Windows могут запустить интерпретатор в командной строке, если уста-
новили переменную PATHнадлежащим образом. Чтобы открыть командную строку в
Windows, зайдите в меню «Пуск» и нажмите «Выполнить…». В появившемся диалого-
вомокневведите”cmd”инажмите Enter;теперьувасбудетвсёнеобходимоедляначала
работысpythonвкоманднойстрокеDOS.
Если вы используете IDLE, нажмите «Пуск» !«Программы» !«Python 3.0» !«IDLE
(PythonGUI)».
Кактольковызапустили python3,выдолжныувидеть >>>вначалестроки,гдевыможете
что-тонабирать.Этоиназывается командной строкой интерпретатора Python
Теперь введите print('Hello World') и нажмите клавишу Enter. В результате должны
появитьсяслова“HelloWorld”.
Вотпримертого,чтовыможетеувидетьнаэкране,еслибудетеиспользоватькомпьютерс
MacOSX.ИнформацияоверсииPythonможетотличатьсявзависимостиоткомпьютера,
ночасть,начинающаясясприглашения(т.е.от >>>идалее)должнабытьодинаковойна
всехоперационныхсистемах.
27
A Byte of Python (Russian), Версия 2.01
$ python3
Python 3.3.0 (default, Oct 22 2012, 12:20:36)
[GCC 4.2.1 Compatible Apple Clang 4.0 ((tags/Apple/clang-421.0.60))] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> print('hello world')
hello world
>>>
Обратитевнимание,чтоPythonвыдаётрезультатработыстрокинемедленно!Вытолько
чтоввелиодиночный«оператор»Python. printиспользуетсядлятого,чтобы(чтонеуди-
вительно1)напечататьлюбоепереданноевнегозначение.Вданномслучаемыпередали
внеготекст“HelloWorld”,которыйибылнапечатаннаэкране.
Совет:Каквыйтиизкоманднойстрокиинтерпретатора
Если вы используете IDLE или оболочку GNU/Linux или BSD, вы можете выйти из ко-
манднойстрокиинтерпретаторанажатием Ctrl-Dиливведякоманду exit()(примеча-
ние:незабудьтенаписатьскобки,“()”),азатемнажавклавишу Enter.Есливыиспользуете
команднуюстрокуWindows,нажмите Ctrl-Z,азатемнажмитеклавишу Enter.
6.3Выбор редактора
Поскольку мы не можемнабирать программу в командной строке интерпретатора каж-
дый раз, когда нам нужно что-то запустить, нам понадобится сохранять программы в
файлах,чтобыпотомиметьвозможностьзапускатьихсколькоугоднораз.
ПреждечемприступитькнаписаниюпрограммнаPythonвфайлах,намнуженредактор
для работы с файлами программ. Выбор редактора крайне важен. Подходить к выбору
редактораследуеттакже,какиквыборуличногоавтомобиля.Хорошийредакторпомо-
жетвамлегкописатьпрограммынаPython,делаявашепутешествиеболеекомфортным,
атакжепозволяябыстрееибезопаснеедостичьвашейцели.
Одноизсамыхосновныхтребований–это подсветка синтаксиса ,когдаразныеэлементы
программынаPythonраскрашенытак,чтобывымоглилегко видетьвашупрограммуи
ходеёвыполнения.
Если вы не знаете, с чего начать, я бы порекомендовал воспользоваться программой
KomodoEdit ,котораядоступнадляWindows,MacOSXиGNU/Linux.
Если вы пользуетесь Windows, Не используйте Блокнот – это плохой выбор, посколь-
куоннеобладаетфункциейподсветкисинтаксиса,атакженепозволяетавтоматически
вставлять отступы, что очень важно в нашем случае, как мы увидим позже. Хорошие
редакторы,какKomodoEdit,позволяютделатьэтоавтоматически.
Опытные программисты, должно быть, уже используют VimилиEmacs. Не стоит даже
и говорить, что это два наиболее мощных редактора, и вы только выиграете от их ис-
1“print”- англ.«Печатать»( прим. перев. )
28 Глава 6. Первые шаги
A Byte of Python (Russian), Версия 2.01
пользования для написания программ на Python. Лично я пользуюсь ими обоими для
большинствасвоихпрограмм,идаженаписал книгуоVim .Янастоятельнорекомендую
вамрешитьсяипотратитьвремянаизучениеVimилиEmacs,посколькуэтобудетприно-
ситьвампользудолгиегоды.Однако,какяужеписалвыше,новичкимогутпокапросто
остановитьсянаKomodoEditисосредоточитьсянаизученииPython,анетекстовогоре-
дактора.
Яповторюсьещёраз:обязательновыберитеподходящийредактор–этосделаетнаписа-
ниепрограммнаPythonболеепростымизанимательным.
ДляпользователейVim
Существует хорошее введение в использование Vim как мощного IDE для
Python, автор – John M Anderson . Также я рекомендую плагин jedi-vim имой
собственныйконфигурационныйфайл .
ДляпользователейEmacs
Существует хорошее введение в использование Emacs как мощного IDE для
Python, автор – Ryan McGuire . Также я рекомендую Конфигурацию dotemacs
отBG.
6.4Использование программных файлов
Атеперьдавайтевернёмсякпрограммированию.Существуеттакаятрадиция,чтокакой
быязыкпрограммированиявыниначиналиучить,первойвашейпрограммойдолжна
бытьпрограмма«Привет,Мир!».Этопрограмма,котораяпростовыводитнадпись«При-
вет,Мир!».КаксказалSimonCozens2,это«традиционноезаклинаниебоговпрограмми-
рования,котороепоможетвамлучшеизучитьязык».
Запуститевыбранныйвамиредактор,введитеследующуюпрограммуисохранитееёпод
именем helloworld.py
Если вы пользуетесь Komodo Edit, нажмите «Файл» !«Новый» !«Новый файл», вве-
дитестроку:
print ('Привет, Мир! ')
ВKomodoEditнажмите«Файл» !«Сохранить»длясохраненияфайла.
Кудасохранитьфайл?Влюбуюпапку,расположениекоторойвызнаете.Есливынепо-
нимаете,чтоэтозначит,тосоздайтеновуюпапкуииспользуйтееёдлявсехвашихпро-
граммнаPython:
•C:\\pyвWindows
•/tmp/pyвGNU/Linux
•/tmp/pyвMacOSX
2Авторвосхитительнойкниги“BeginningPerl”
6.4. Использование программных файлов 29
A Byte of Python (Russian), Версия 2.01
Чтобы создать папку, воспользуйтесь командой mkdirв терминале. Например, mkdir
/tmp/py.
Важно:Незабывайтеуказыватьрасширениефайла .py.Например,« file.py».
В Komodo Edit нажмите «Инструменты» !«Запуск команды», наберите python3
helloworld.py и нажмите «Выполнить». Вы должны увидеть вывод, показанный на
скриншотениже.
Новсё-такилучшередактироватьпрограммувKomodoEdit,азапускатьвтерминале:
1.Откройтетерминал,какописановглаве Установка .
2.Перейдитевкаталог,вкоторомвысохранилифайл.Например, cd /tmp/py .
3.Запуститепрограмму,введякоманду python3 helloworld.py .
30 Глава 6. Первые шаги
A Byte of Python (Russian), Версия 2.01
Выводпрограммыпоказанниже.
$ python3 helloworld.py
Привет, Мир!
Если у вас получился такой же вывод, поздравляю! – вы успешно выполнили вашу
первую программу на Python. Вы только что совершили самый сложный шаг в обуче-
ниипрограммированию,заключающийсявнаписаниисвоейпервойпрограммы!
Есливыполучитесообщениеобошибке,введитевышеуказаннуюпрограмму в точности
так, как показано здесь, и запустите снова. Обратите внимание, что Python различает
регистрбукв,тоесть print–этонетожесамое,что Print(обратитевниманиенабукву
pвнижнемрегистревпервомслучаеинабукву Pвверхнемрегистревовтором).Также
убедитесь, что перед первым символом в строке нет пробелов или символов табуляции
–позжемыувидим,почемуэтоважно.
Как это работает
ПрограмманаPythonсостоитиз выражений .Внашейпервойпрограммеиме-
етсявсеголишьодновыражение.Вэтомвыражениимывызываемфункцию
print, которая просто выводит текст 'Привет, Мир!' . О функциях мы узна-
емв одной из последующих глав ,апокавамдостаточнопонять,чтовсё,чтовы
укажете в скобках, будет выведено на экран. В данном примере мы указали
'Привет, Мир!' .
6.4.1 Исполнимые программы на Python
Это касается только пользователей GNU/Linux и Unix, но пользователям Windows тоже
будетполезнообэтомзнать.
Каждыйраз,когданамнужнозапуститьпрограммунаPython,намприходитсявявном
видезапускать python3 foo.py .Нопочемубынамнезапускатьеёточнотакже,какивсе
другиепрограммы?Этогоможнодостичьприпомощитакназываемого hashbang.
Добавьтестроку,указаннуюниже,в самое начало вашейпрограммы:
#!/usr/bin/env python3
Теперьвашапрограммадолжнавыглядетьтак:
#!/usr/bin/env python3
print ('Привет, Мир! ')
Теперь необходимо установить программе атрибут исполнимости, используя команду
chmod,азатем выполнить программу.
Команда chmodздесьиспользуетсядляизменениярежимафайла3добавлениематрибута
исполнимостидлявсехпользователейвсистеме4.
3ange mode-англ.«изменитьрежим»( прим. перев. )
4В указанной команде буква “ a” взята из слова “ all” (англ.«все»), а буква “ x” – из слова “e xecute” ( англ.
«исполнять»)– прим. перев.
6.4. Использование программных файлов 31
A Byte of Python (Russian), Версия 2.01
$ chmod a+x helloworld.py
После этого мы можем запускать программу напрямую, потому что наша операцион-
наясистемазапустит /usr/bin/env ,который,всвоюочередь,найдётPython3,азначит,
сможетзапуститьнашфайл.
$ ./helloworld.py
Привет, Мир!
Здесь“ ./”обозначает,чтопрограмманаходитсявтекущемкаталоге.
Ради интереса можете даже переименовать файл в просто “ helloworld ” и запустить его
как./helloworld , и это также сработает, поскольку система знает, что запускать про-
грамму нужно интерпретатором, положение которого указано в первой строке файла
программы.
Но до сих пор мы могли выполнять свою программу только если знали полный путь
к ней. А что, если нам нужно запускать эту программу из любого каталога? Это мож-
но организовать, расположив свою программу в одном из каталогов, перечисленных в
переменнойокружения PATH.
При попытке запуска какой-либо программы система ищет её в каталогах, перечислен-
ныхвпеременнойокружения PATH,изапускает.Такимобразом,мыможемсделатьпро-
граммудоступнойизлюбогоместа,скопировавеёводинизкаталогов,перечисленных
вPATH.
$ echo $PATH
/usr/local/bin:/usr/bin:/bin:/usr/X11R6/bin:/home/swaroop/bin
$ cp helloworld.py /home/swaroop/bin/helloworld
$ helloworld
Привет, Мир!
Мыможемвывестинаэкранзначениепеременной PATHприпомощикоманды echo,до-
бавивпередименемпеременнойсимвол $,чтобыуказатьоболочке,чтомыхотимполу-
читьзначениеэтойпеременной.Мывидим,что /home/swaroop/bin –одинизкаталогов
в переменной PATH, где swaroop– это имя пользователя, которое я использую в своей
системе. В вашей системе, скорее всего, будет аналогичный каталог для вашего пользо-
вателя.
Вы также можете добавить какой-либо каталог к переменной PATH– это можно сделать,
выполнив PATH=$PATH:/home/swaroop/mydir , где '/home/swaroop/mydir' – это каталог,
которыйяхочудобавитькпеременной PATH.
Этотметодполезендлянаписаниясценариев,которыебудутдоступныдлязапускавлю-
бой момент из любого места. По сути, это равносильно созданию собственных команд,
какcdилилюбойдругой,которыечастоиспользуютсявтерминалеGNU/Linuxилипри-
глашенииDOS.
Примечание: Когда речь идёт о Python, слова «программа» или «сценарий (скрипт)»
обозначаютодноитоже.
32 Глава 6. Первые шаги
A Byte of Python (Russian), Версия 2.01
6.5Получение помощи
Для быстрого получения информации о любой функции или операторе Python служит
встроенная функция help. Это особенно удобно при использовании командной строки
интерпретатора.Кпримеру,выполните help(print) –этопокажетсправкупофункции
print,котораяиспользуетсядлявыводанаэкран.
Примечание: Длявыходаизсправкинажмите q.
АналогичнымобразомможнополучитьинформациюпочтиочёмугодновPython.При
помощифункции help()можнодажеполучитьописаниесамойфункции help!
Если вас интересует информация об операторах, как например, return, их необходимо
указыватьвкавычках(например, help('return') ),чтобыPythonпонял,чегомыхотим.
6.6Резюме
Теперьвыумеетеслёгкостьюписать,сохранятьизапускатьпрограммынаPython.
И поскольку сейчас вы уже используете Python, давайте узнаем больше о его основных
принципах.
6.5. Получение помощи 33
A Byte of Python (Russian), Версия 2.01
34 Глава 6. Первые шаги
Основы
Простонапечатать«Привет,Мир!»недостаточно,верно?Выхотитесделатьбольше–вы
хотитеввестичто-товпрограмму,обработатьиполучитьнечтонавыходе.ВPythonэто
можноорганизоватьприпомощиконстантипеременных,атакженекоторымидругими
способами,которыебудутрассмотренывэтойглаве.
7.1Комментарии
Комментарии – это то, что пишется после символа #, и представляет интерес лишь как
заметкадлячитающегопрограмму.
Например:
print ('Привет, Мир!) # print -- это функция
или:
# print -- это функция
print ('Привет, Мир!)
Старайтесьвсвоихпрограммахписатькакможнобольшеполезныхкомментариев,объ-
ясняющих:
•предположения;
•важныерешения;
•важныедетали;
•проблемы,которыевыпытаетесьрешить;
•проблемы,которыхвыпытаетесьизбежатьит.д.
Текстпрограммыговоритотом,КАК,акомментариидолжныобъяснять,ПОЧЕМУ .
Это будет полезно для тех, кто будет читать вашу программу, так как им легче будет
понять,чтопрограммаделает.Помните,чтотакимчеловекомможетеоказатьсявысами
черезполгода!
35
A Byte of Python (Russian), Версия 2.01
7.2Литеральные константы
Примером литеральной константы может быть число, например, 5,1.23,9.25e-3или
что-нибудьвроде 'Это строка' или "It's a string!" .Ониназываютсялитеральными,
потому что они «буквальны»1– вы используете их значение буквально. Число 2всегда
представляетсамосебяиничегодругого–это«константа»,потомучтоеёзначениенель-
зяизменить.Поэтомувсёэтоназываетсялитеральнымиконстантами.
7.3Числа
ЧиславPythonбываюттрёхтипов:целые,сплавающейточкойикомплексные.
•Примеромцелогочисламожетслужить 2.
•Примерами чисел с плавающей точкой (или «плавающих» для краткости) могут
быть 3.23и52.3E-4.Обозначение Eпоказываетстепеничисла10.Вданномслучае
52.3E-4означает 52:310 4.
•Примерыкомплексныхчисел: (-5+4j)и(2.3 - 4.6j)
Замечание для опытных программистов
Нет отдельного типа ‘long int’ (длинное целое). Целые числа по умолчанию могут быть
произвольнойдлины.
7.4Строки
Строка – это последовательность символов . Чаще всего строки – это просто некоторые
наборыслов.
Слова могут быть как на английском языке, так и на любом другом, поддерживаемом
стандартомUnicode,чтоозначает почтиналюбомязыкемира .
Замечание для опытных программистов
В Python 3 нет ASCII-строк, потому что Unicode является надмножеством (включает в
себя) ASCII. Если необходимо получить строку строго в кодировке ASCII, используйте
str.encode("ascii") .Подробнеесмотритев обсужденииэтоговопросанаStackOverﬂow .
ПоумолчаниювсестрокивUnicode.
Я могу с уверенностью сказать, что вы будете использовать строки почти в каждой ва-
шейпрограмменаPython.Поэтомууделитевниманиетому,какработатьсострокамив
Python.
1“literal”– англ.«буквальный»;вспомните«литера»( син.«буква»).( прим. перев. )
36 Глава 7. Основы
A Byte of Python (Russian), Версия 2.01
7.4.1 Одинарные кавычки
Строку можно указать, используя одинарные кавычки, как например, 'Фраза в кавыч-
ках'.Всепробелыизнакитабуляциисохранятся,какесть.
7.4.2 Двойные кавычки
Строки в двойных кавычках работают точно так же, как и в одинарных. Например,
"What's your name?" .
7.4.3 Тройные кавычки
Можноуказывать«многострочные»строкисиспользованиемтройныхкавычек( """или
''').Впределахтройныхкавычекможносвободноиспользоватьдвойныеилитройные
кавычки.Например:
'''Это многострочная строка. Это её первая строка.
Это её вторая строка.
"What's your name?", - спросил я.
Он ответил: "Bond, James Bond."
'''
7.4.4 Строки неизменяемы
Это означает, что после создания строки её больше нельзя изменять. На первый взгляд
этоможетпоказатьсянедостатком,нонасамомделеэтонетак.Впоследствиинапримере
разныхпрограмммыувидим,почемуэтонеявляетсяограничением.
7.4.5 Объединение строковых констант
Если расположить рядом две строковых константы, Python автоматически их объеди-
нит.Например, 'What\'s ' 'your name?' автоматическипреобразуетсяв "What's your
name?".
Замечание для программистов на C/C++
ВPythonнетотдельноготипаданных char(символ).Внёмнетнужды,ияуверен,чтовы
небудетепонемускучать.
Замечание для программистов на Perl/PHP
Помните,чтострокивдвойныхкавычкахиводинарныхэквивалентны,иничемдругот
друганеотличаются.
7.4. Строки 37
A Byte of Python (Russian), Версия 2.01
7.4.6 Метод format
Иногдабываетнужносоставитьстрокунаосновекаких-либоданных.Вотздесь-тоипри-
гождаетсяметод format().
Сохранитеследующиестрокивфайл str_format.py :
age =26
name ='Swaroop '
print ('Возраст {0} -- {1} лет. '.format(name, age))
print ('Почему {0} забавляется с этим Python? '.format(name))
Вывод:
$ python str_format.py
Возраст Swaroop -- 26 лет.
Почему Swaroop забавляется с этим Python?
Как это работает:
В строку могут быть включены определённые обозначения, а впоследствии
может быть вызван метод formatдля замещения этих обозначений соответ-
ствующимиаргументами.
Взглянитенапервыйслучайпримененияобозначений,гдемыпишем {0},и
этосоответствуетпеременной name,являющейсяпервымаргументомметода
format. Аналогично, второе обозначение {1}соответствует переменной age,
являющейсявторымаргументомметода format.Заметьте,чтоPythonначина-
етотсчётс0,поэтомуперваяпозиция–номер0,вторая–номер1ит.д.
Заметьте,мыведьмоглидобитьсятогожесамогорезультатаиобъединением
строк: 'Возраст' + name + ' -- ' + str(age) + ' лет.' , однако вы сами
видите,какэтонекрасиво,икаклегковтакомслучаедопуститьошибку.Во-
вторых, преобразование в строку делается методом formatавтоматически, в
отличие от явного преобразования в нашем примере. В-третьих, используя
метод format, мы можем изменить сообщение, не затрагивая используемых
переменных,инаоборот.
На всякий случай имейте в виду, что цифры здесь не обязательны. Можно
былобыпростонаписать:
age =26
name ='Swaroop '
print ('Возраст {} -- {} лет. '.format(name, age))
print ('Почему {} забавляется с этим Python? '.format(name))
иполучитьтакойжерезультат,какиранее.
В методе formatPython помещает значение каждого аргумента в обозначенное место.
Могутбытьиболеедетальныеобозначения,както:
38 Глава 7. Основы
A Byte of Python (Russian), Версия 2.01
>>> # десятичное число (.) с точностью в 3 знака для плавающих:
... '{0:.3} '.format( 1/3)
'0.333'
>>> # заполнить подчёркиваниями (_) с центровкой текста (^) по ширине 11:
... '{0:_^11} '.format( 'hello ')
'___hello___'
>>> # по ключевым словам:
... '{name} написал {book} '.format(name ='Swaroop ', book ='A Byte of Python ')
'Swaroop написал A Byte of Python'
ДетальнотакиеобозначенияформатовописанывПредложениипорасширениюPython
PEP 3101.
7.5Переменные
Использование одних лишь литеральных констант может скоро наскучить – нам ведь
нужен способ хранения любой информации и манипулирования ею. Вот здесь на сце-
нувыходят переменные .Слово«переменные»говоритсамозасебя–ихзначениеможет
меняться,азначит,выможетехранитьвпеременнойвсё,чтоугодно.Переменные–это
просто области памяти компьютера, в которых вы храните некоторую информацию. В
отличие от констант, к такой информации нужно каким-то образом получать доступ,
поэтомупеременнымдаютсяимена.
7.6Имена идентификаторов
Переменные–эточастныйслучайидентификаторов. Идентификаторы –этоимена,при-
своенные чему-тодляегообозначения.Привыбореимёндляидентификаторовнеобхо-
димособлюдатьследующиеправила:
•Первымсимволомидентификаторадолжнабытьбукваизалфавита(символASCII
вверхнемилинижнемрегистре,илисимволUnicode),атакжесимволподчёркива-
ния(“_”).
•Остальнаячастьидентификатораможетсостоятьизбукв(символыASCIIвверхнем
или нижнем регистре, а также символы Unicode), знаков подчёркивания (“_”) или
цифр(0-9).
•Имена идентификаторов чувствительны к регистру. Например, mynameиmyName–
этонеодноитоже.Обратитевниманиена“ n”внижнемрегистревпервомслучае
и“N”вверхнемвовтором.
•Примеры допустимых имёнидентификаторов: i,__my_name ,name_23,a1b2_c3илю-
бые_символы_utf8_δξѪђёўЩӆΞέά .
•Примеры недопустимых имёнидентификаторов: 2things,здесь есть пробелы ,my-
name,>a1b2_c3 и"это_в_кавычках" .
7.5. Переменные 39
A Byte of Python (Russian), Версия 2.01
7.7Типы данных
Переменные могут хранить значения разных типов, называемых типами данных . Ос-
новнымитипами являются числа и строки, о которыхмы ужеговорили. В дальнейших
главахмыувидим,каксоздаватьсвоисобственныетипыприпомощи классов.
7.8Объекты
Помните, Python рассматривает всё, что есть в программе, как объекты. Имеется в виду,
всамомобщемсмысле.Вместотого,чтобыговорить“ нечто”,мыговорим“ объект”.
Замечание для программистов в объектно-ориентированном стиле
Pythonстрогообъектноориентированвтомсмысле,чтообъектомявляетсявсё,включая
числа,строкиифункции.
Сейчасмыувидим,какиспользоватьпеременныенарядусконстантами.Сохранитесле-
дующийпримеризапуститепрограмму.
Как писать программы на Python
ВпредьстандартнаяпроцедурасохраненияизапускапрограммынаPythonбудетвыгля-
детьтак:
1.Откройтевашлюбимыйредактор,напримерKomodoEdit.
2.Введитетекстпрограммыизпримера.
3.Сохранитееговфайл,указавегоимявкомментарии.Яследуюправилусохранять
всепрограммынаPythonсрасширением .py.
4.Запустите интерпретатор командой python3 program.py . Кроме того, вы можете
сделатьпрограмму исполнимой ,какобъяснялосьранее.
7.8.1 Пример: Использование переменных и констант
# Имя файла : var.py
i=5
print (i)
i=i+1
print (i)
s='''Это многострочная строка.
Это вторая её строчка. '''
print (s)
40 Глава 7. Основы
A Byte of Python (Russian), Версия 2.01
Вывод:
$ python var.py
5
6
Это многострочная строка.
Это вторая её строчка.
Как это работает:
Вот как эта программа работает. Сперва мы присваиваем значение констан-
ты5переменной i, используя оператор присваивания ( =). Эта строка назы-
вается предложением и указывает, что должно быть произведено некоторое
действие, и в данном случае мы связываем имя переменной iсо значением
5.Затеммыпечатаемзначение i,используяфункцию print,котораяпросто
печатаетзначениепеременнойнаэкране.
Далеемыдобавляем 1кзначению,хранящемусяв iисохраняемеготам.После
этогомыпечатаемегоиполучаемзначение 6,чтонеудивительно.
Аналогичнымобразоммыприсваиваемстроковуюконстантупеременной s,
послечегопечатаемеё.
Замечание для программистов на статических языках программирования
Переменные используются простым присваиванием им значений. Никакого предвари-
тельногообъявленияилиопределениятипаданныхнетребуется/применяется.
7.9Логические и физические строки
Физическаястрока–этото,чтовы видите,когданабираетепрограмму.Логическаястро-
ка – это то, что Python видит как единое предложение. Python неявно предполагает, что
каждой физической строке соответствует логическая строка .
Примеромлогическойстрокиможетслужитьпредложение print('Привет, Мир!') –ес-
лиононаоднойстроке(каквывидитеэтовредакторе),тоэтастрокатакжесоответствует
физическойстроке.
Python неявно стимулирует использование по одному предложению на строку, что об-
легчаетчтениекода.
Чтобызаписатьболееоднойлогическойстрокинаоднойфизическойстроке,вампридёт-
сяявноуказатьэтоприпомощиточкисзапятой( ;),котораяотмечаетконецлогической
строки/предложения.Например,
i=5
print (i)
тожесамое,что
7.9. Логические и физические строки 41
A Byte of Python (Russian), Версия 2.01
i=5;
print (i);
итожесамоеможетбытьзаписановвиде
i=5;print (i);
илидаже
i=5;print (i)
Однакоя настоятельно рекомендую вампридерживаться написания одной логической
строки в каждой физической строке . Таким образом вы можете обойтись совсем без
точки с запятой. Кстати, я никогдане использовал и даже не встречал точки с запятой в
программахнаPython.
Можноиспользоватьболееоднойфизическойстрокидлялогическойстроки,нокэтому
следуетприбегатьлишьвслучаеоченьдлинныхстрок.Примернаписанияоднойлогиче-
скойстроки,занимающейнесколькофизическихстрок,приведённиже.Этоназывается
явным объединением строк .
s='Это строка. \
Это строка продолжается. '
print (s)
Этодастрезультат:
Это строка. Это строка продолжается.
Аналогично,
print \
(i)
тожесамое,чтои
print (i)
Иногдаимеетместонеявноеподразумевание,когдаиспользованиеобратнойкосойчер-
ты не обязательно. Это относится к случаям, когда в логической строке есть открываю-
щаясякруглая,квадратнаяилифигурнаяскобка,нонетзакрывающейся.Этоназывается
неявным объединением строк .Высможетеувидетьэтовдействиивпрограммахсис-
пользованием списковвдальнейшихглавах.
7.10 Отступы
В Python пробелы важны. Точнее, пробелы в начале строки важны . Это называется от-
ступами.Передниеотступы(пробелыитабуляции)вначалелогическойстрокиисполь-
42 Глава 7. Основы
A Byte of Python (Russian), Версия 2.01
зуютсядляопределенияуровняотступалогическойстроки,который,всвоюочередь,ис-
пользуетсядлягруппировкипредложений.
Этоозначает,чтопредложения,идущиевместе, должныиметьодинаковыйотступ.Каж-
дый такой набор предложений называется блоком. В дальнейших главах мы увидим
примерытого,наскольковажныблоки.
Вы должны запомнить, что неправильные отступы могут приводить к возникновению
ошибок.Например:
i=5
print ('Значение составляет ', i) # Ошибка! Пробел в начале строки
print ('Я повторяю, значение составляет ', i)
Когдавызапуститеэто,выполучитеследующуюошибку:
File "whitespace.py", line 4
print('Значение составляет ', i) # Ошибка! Пробел в начале строки
^
IndentationError: unexpected indent
Обратитевниманиенато,чтовначалевторойстрокиестьодинпробел.Ошибка,отобра-
жённаяPython,говоритнамотом,чтосинтаксиспрограммыневерен,т.е.программане
быланаписанапоправилам.Длявасжеэтоозначает,что вы не можете начинать новые
блоки предложений где попало (кромеосновногоблокапоумолчанию,которыйиспользу-
етсянапротяжениивсейпрограммы,конечно).Случаи,вкоторыхвыможетеиспользо-
ватьновыеблоки,будутподробноописанывдальнейшихглавах,какнапример,в главе
«Поток команд» .
Как отступать
Несмешивайте пробелы и символы табуляции в отступах, поскольку не на всех плат-
формахэтоработаеткорректно.Я настоятельно рекомендую вамиспользовать одиночную
табуляцию или четыре пробела длякаждогоуровняотступа.
Выберите какой-нибудь один из этих стилей отступа. Но что ещё более важно, это ис-
пользоватьвыбранныйстиль постоянно ,атакжесоблюдатьстильредактируемыхвами
файлов.Т.е.когдавыпишетеновыйфайл,используйте толькоодинвашлюбимыйстиль,
а если в редактируемом вами файле для отступов уже используются, скажем, символы
табуляции,тоивыиспользуйтевэтомфайлесимволытабуляциидляотступов.
Хорошиередакторы,такиекакKomodoEdit,будуделатьэтоавтоматически.
Замечание для программистов на статических языках программирования
Pythonвсегдабудетиспользоватьотступыдлявыделенияблоковиникогданебудетис-
пользоватьскобки.Введите from __future__ import braces ,чтобыузнатьбольше.
7.10. Отступы 43
A Byte of Python (Russian), Версия 2.01
7.11 Резюме
Теперь,когдамыпрошличерезмножествожизненноважныхмелочей,можноперейтик
болееинтереснымвещам–такимкакуправляющиеконструкции.Носначалакакследует
освойтесьспрочитаннымвнастоящейглаве.
44 Глава 7. Основы
Операторы и выражения
Большинствопредложений(логическихстрок)впрограммахсодержат выражения .Про-
стойпримервыражения: 2 + 3.Выражениеможноразделитьнаоператорыиоперанды.
Операторы –этонекийфункционал,производящийкакие-либодействия,которыймо-
жет быть представлен в виде символов, как например +, или специальных зарезерви-
рованныхслов.Операторымогутпроизводитьнекоторыедействиянадданными,иэти
данныеназываются операндами .Внашемслучае 2и3–этооперанды.
8.1Операторы
Краткорассмотримоператорыиихприменение:
Обратите внимание, вычислить значения выражений, данных в примерах, можно так-
же используя интерпретатор интерактивно. Например, для проверки выражения 2 + 3
воспользуйтесьинтерактивнойкоманднойстрокойинтерпретатораPython:
>>> 2+3
5
>>> 3*5
15
Операторы и их применение
Оператор Назва-
ниеОбъяснение Примеры
+Сложе-
ниеСуммируетдваобъекта 3 + 5даст 8;'a' + 'b' даст
'ab'
-Вычи-
таниеДаётразностьдвухчисел;если
первыйоперандотсутствует,
онсчитаетсяравнымнулю-5.2дастотрицательное
число,а 50 - 24даст 26.
*Умно-
жениеДаётпроизведениедвухчисел
иливозвращаетстроку,
повторённуюзаданноечисло
раз.2 * 3даст 6.'la' * 3 даст
'lalala'.
45
A Byte of Python (Russian), Версия 2.01
Оператор Назва-
ниеОбъяснение Примеры
**Возве-
дениев
степеньВозвращаетчисло х,
возведённоевстепень y3 ** 4даст 81(т.е.3 * 3 * 3
* 3)
/Деление Возвращаетчастноеот
деления xнаy4 / 3даст
1.3333333333333333 .
//Цело-
чис-
ленное
деле-
ниеВозвращаетнеполноечастное
отделения4 // 3даст 1.
%Деление
помо-
дулюВозвращаетостатокот
деления8 % 3даст 2.-25.5 % 2.25
даст 1.5.
<<Сдвиг
влевоСдвигаетбитычиславлевона
заданноеколичество
позиций.(Любоечислов
памятикомпьютера
представленоввидебитов-
илидвоичныхчисел,т.е.0и1)2 << 2даст 8.Вдвоичном
виде 2представляетсобой 10.
Сдвигвлевона2битадаёт
1000,чтовдесятичномвиде
означает 8.
>>Сдвиг
вправоСдвигаетбитычиславправо
назаданноечислопозиций.11 >> 1даст 5.Вдвоичном
виде 11представляетсякак
1011,чтобудучисмещённым
на1битвправо,даёт 101,аэто,
всвоюочередь,ничтоиное
какдесятичное 5
&Поби-
товое
ИПобитоваяоперацияИнад
числами5 & 3даёт 1.
|Поби-
товое
ИЛИПобитоваяоперацияИЛИнад
числами5 | 3даёт 7
^Поби-
товое
ИС-
КЛЮ-
ЧИ-
ТЕЛЬ-
НО
ИЛИПобитоваяоперация
ИСКЛЮЧИТЕЛЬНОИЛИ5 ^ 3даёт 6
~Поби-
товое
НЕПобитоваяоперацияНЕдля
числа xсоответствует -(x+1)~5даёт -6.
46 Глава 8. Операторы и выражения
A Byte of Python (Russian), Версия 2.01
Оператор Назва-
ниеОбъяснение Примеры
<Меньше Определяет,верноли,что x
меньше y.Всеоператоры
сравнениявозвращают True
или False1.Обратите
вниманиеназаглавныебуквы
вэтихсловах.5 < 3даст False,
а3 < 5даст True.
Можносоставлять
произвольныецепочки
сравнений: 3 < 5 < 7 даёт
True.
>Больше Определяет,верноли,что x
больше y5 > 3даёт True.Еслиоба
операнда-числа,топеред
сравнениемониоба
преобразуютсякодинаковому
типу.Впротивномслучае
всегдавозвращается False.
<=Меньше
или
равноОпределяет,верноли,что x
меньшеилиравно yx = 3; y = 6; x <= y даёт
True.
>=Больше
или
равноОпределяет,верноли,что x
большеилиравно yx = 4; y = 3; x >= 3 даёт
True.
==Равно Проверяет,одинаковыли
объектыx = 2; y = 2; x == y даёт
True.x = 'str'; y = 'stR';
x == yдаёт False.x = 'str';
y = 'str'; x == y даёт True.
!=Не
равноПроверяет,верноли,что
объектынеравныx = 2; y = 3; x != y даёт
True.
not Логи-
ческое
НЕЕсли xравно True,оператор
вернёт False.Еслиже xравно
False,получим True.x = True; not x даёт False.
and Логи-
ческое
Иx and yдаёт False,если x
равно False,впротивном
случаевозвращаетзначение yx = False; y = True; x and
yвозвращает False,поскольку
xравно False.Вэтомслучае
Pythonнестанетпроверять
значение y,таккакужезнает,
чтолеваячастьвыражения
‘and’равняется False,что
подразумевает,чтоивсё
выражениевцеломбудет
равно False,независимоот
значенийвсехостальных
операндов.Этоназывается
укороченнойоценкойбулевых
(логических)выражений.
1“True”- англ.«Верно(Правда)»;“False”- англ.“«ибочно(Ложь)».( прим. перев. )
8.1. Операторы 47
A Byte of Python (Russian), Версия 2.01
Оператор Назва-
ниеОбъяснение Примеры
orЛоги-
ческое
ИЛИЕсли xравно True,в
результатеполучим True,в
противномслучаеполучим
значение yx = True; y = False; x or y
даёт True.Здесьтакжеможет
производитьсяукороченная
оценкавыражений.
8.1.1 Краткая запись мат. операций и присваивания
Зачастуюрезультатпроведениянекойматематическойоперациинеобходимоприсвоить
переменной, над которой эта операция производилась. Для этого существуют краткие
формызаписивыражений:
Выможетезаписать:
a=2; a =a*3
ввиде:
a=2; a *=3
Обратитевнимание,чтовыражениявида« переменная = переменная операция выраже-
ние»принимаетвид« переменная операция = выражение ».
8.2Порядок вычисления
Еслиимеетсявыражениевида 2 + 3 * 4 ,чтопроизводитсяраньше:сложениеилиумно-
жение?Школьныйкурсматематикиговоритнам,чтоумножениедолжнопроизводиться
впервуюочередь.Этоозначает,чтооператорумноженияимеетболеевысокийприори-
тет,чемоператорсложения.
Следующая таблица показывает приоритет операторов в Python, начиная с самого низ-
кого (самое слабое связывание) и до самого высокого (самое сильное связывание). Это
означает,чтовлюбомвыраженииPythonспервавычисляетоператорыивыражения,рас-
положенныевнизутаблицы,азатемоператорывышепотаблице.
Эта таблица взята из Справочника по языку Python (англ.) и приводится здесь для пол-
нотыописания.Напрактикелучшеиспользоватьскобкидлягруппировкиоператорови
операндов,чтобывявномвидеуказатьпорядоквычислениявыражений.Заодноэтооб-
легчит чтение программы. Более подробно см. в разделе Изменение порядка вычисления
ниже.
48 Глава 8. Операторы и выражения
A Byte of Python (Russian), Версия 2.01
Приоритет операторов
Оператор Описание
lambda лямбда-выражение
or Логическое“ИЛИ”
and Логическое“И”
not x Логическое“НЕ”
in,not in Проверкапринадлежности
is,is not Проверкатождественности
<,<=,>,>=,!=,==Сравнения
| Побитовое“ИЛИ”
^ Побитовое“ИСКЛЮЧИТЕЛЬНОИЛИ”
& Побитовое“И”
<<,>> Сдвиги
+,- Сложениеивычитание
*,/,//,% Умножение,деление,целочисленноеделениеиостатокотделения
+x,-x Положительное,отрицательное
~x ПобитовоеНЕ
** Возведениевстепень
x.attribute Ссылканаатрибут
x[индекс] Обращениепоиндексу
x[индекс1:индекс2] Вырезка
f(аргументы ...) Вызовфункции
(выражения, ...) Связкаиликортеж2
[выражения, ...] Список
{ключ:данные, ...} Словарь
Операторы,окоторыхмынеупомянули,будутобъясненывдальнейшихглавах.
Вэтойтаблицеоператорыс равным приоритетом расположеныводнойстроке.Напри-
мер, +и-имеютравныйприоритет.
8.3Изменение порядка вычисления
Дляоблегчениячтениявыраженийможноиспользоватьскобки.Например, 2 + (3 * 4)
определённолегчепонять,чем 2 + 3 * 4,котороетребуетзнанияприоритетаоператоров.
Какивсёостальное,скобкинужноиспользоватьразумно(неперестарайтесь)иизбегать
излишних,какв (2 + (3 * 4)) .
Есть ещё одно преимущество в использовании скобок – они дают возможность изме-
нить порядок вычисления выражений. Например, если сложение необходимо произве-
стипреждеумножения,можнозаписатьнечтовроде (2 + 3) * 4 .
2“tuple”- англ.«кортеж»( прим. перев. )
8.3. Изменение порядка вычисления 49
A Byte of Python (Russian), Версия 2.01
8.4Ассоциативность
Операторыобычнообрабатываютсяслеванаправо.Этоозначает,чтооператорысравным
приоритетомбудут обработаны по порядку от левого до правого.Например, 2 + 3 + 4
обрабатываетсякак (2 + 3) + 4 .Некоторыеоператоры,как,например,операторприсва-
ивания,имеютассоциативностьсправаналево,т.е. a = b = c рассматриваетсякак a = (b
= c).
8.5Выражения
Пример(сохранитекак expression.py ):
length =5
breadth =2
area =length *breadth
print ('Площадь равна ', area)
print ('Периметр равен ',2*(length +breadth))
Вывод:
$ python expression.py
Площадь равна 10
Периметр равен 14
Как это работает:
Длина и ширина прямоугольника хранятся в переменных lengthиbreadth
соответственно. Мы используем их для вычисления периметра и площади
прямоугольника при помощи выражений. Результат выражения length *
breadthсохраняетсявпеременной area,послечеговыводитсянаэкранфунк-
цией print. Во втором случае мы напрямую подставляем значение выраже-
ния 2 * (length + breadth) вфункцию print.
Такжеобратитевнимание,какPython«красивопечатает»результат.Несмотря
нато,чтомынеуказалипробеламежду 'Площадь равна' ипеременной area,
Pythonподставляетегозанас,чтобыполучитькрасивыйипонятныйвывод.
Программажеостаётсяприэтомлегкочитаемой(посколькунамненужноза-
ботитьсяопробелахмеждустроками,которыемывыводим).Этопримертого,
какPythonоблегчаетжизньпрограммисту.
8.6Резюме
Мыувидели,какпользоватьсяоператорами,операндамиивыражениями.Этоосновные
строительные блоки любой программы. Далее мы увидим, как это применить на прак-
тике.
50 Глава 8. Операторы и выражения
Поток команд
Впрограммах,которыемыдосихпоррассматривали,последовательностькомандвсегда
выполнялась Python по порядку строго сверху вниз. А что, если нам необходимо изме-
нить поток выполняющихся команд? Например,если требуется,чтобы программа при-
нимала некоторое решение и выполняла различные действия в зависимости от ситуа-
ции; скажем, печатала «Доброе утро» или «Добрый вечер» в зависимости от времени
суток.
Каквыуже,наверное,догадались,этогоможнодостичьприпомощиоператоровуправ-
ленияпотоком.ВPythonестьтриоператорауправленияпотоком: if,forиwhile.
9.1Оператор if
Оператор ifиспользуетсядляпроверкиусловий: если1условиеверно2,выполняетсяблок
выражений(называемый«if-блок»), иначе3выполняетсядругойблоквыражений(назы-
ваемый«else-блок»).Блок«else»являетсянеобязательным.
Пример: (сохранитекак if.py)
number =23
guess =int(input ('Введите целое число : '))
ifguess ==number:
print ('Поздравляю, вы угадали, ')# Здесь начинается новый блок
print ('(хотя и не выиграли никакого приза!) ')# Здесь заканчивается новый блок
elif guess <number:
print ('Нет, загаданное число немного больше этого. ')# Ещё один блок
# Внутри блока вы можете выполнять всё, что угодно ...
else :
print ('Нет, загаданное число немного меньше этого. ')
# чтобы попасть сюда, guess должно быть больше, чем number
print ('Завершено ')
# Это последнее выражение выполняется всегда после выполнения оператора if
1if–англ.«если»( прим.перев. )
2Соответствуетбулевомузначению True(прим.перев. )
3else– англ.«иначе»,«впротивномслучае»( прим.перев. )
51
A Byte of Python (Russian), Версия 2.01
Вывод:
$ python if.py
Введите целое число : 50
Нет, загаданное число немного меньше этого.
Завершено
$ python if.py
Введите целое число : 22
Нет, загаданное число немного больше этого.
Завершено
$ python if.py
Введите целое число : 23
Поздравляю, вы угадали,
(хотя и не выиграли никакого приза.)
Завершено
Как это работает:
В этой программе мы принимаем варианты от пользователя и проверяем,
совпадают ли они с заранее заданным числом. Мы устанавливаем перемен-
ной numberзначениелюбогоцелогочисла,какогохотим.Например, 23.После
этого мы принимаем вариант числа от пользователя при помощи функции
input().Функции–этовсего-навсегомногократноиспользуемыефрагменты
программы.Мыузнаемонихбольшев следующей главе .
Мы передаём встроенной функции inputстроку, которую она выводит на
экран и ожидает ввода от пользователя. Как только мы ввели что-нибудь и
нажаликлавишу Enter,функция input()возвращаетстроку,которуюмывве-
ли.Затеммыпреобразуемполученнуюстрокувчислоприпомощи int(),и
сохраняем это значение в переменную guess. Вообще-то, int– это класс, но
на данном этапе вам достаточно знать лишь, что при помощи него можно
преобразоватьстрокувцелоечисло(предполагая,чтострокасодержитцелое
число).
Далеемысравниваемчисло,введённоепользователем,счислом,котороемы
выбрали заранее. Если они равны, мы печатаем сообщение об успехе. Обра-
тите внимание,что мы используемсоответствующие уровни отступа, чтобы
указатьPython,какиевыраженияотносятсяккакомублоку.Вотпочемуотсту-
пытакважнывPython.Янадеюсь,выпридерживаетесьправила«постоянных
отступов»,нетакли?
Обратитевнимание,чтовконцеоператора ifстоитдвоеточие–этиммыпо-
казываем,чтодалееследуетблоквыражений.
После этого мы проверяем, верно ли, что пользовательский вариант числа
меньше загаданного, и если это так, мы информируем пользователя о том,
что ему следует выбирать числа немного больше этого. Здесь мы использо-
52 Глава 9. Поток команд
A Byte of Python (Russian), Версия 2.01
вали выражение elif, которое попросту объединяет в себе два связанных if
else-if else выраженияводновыражение if-elif-else .Этооблегчаетчте-
ниепрограммы,атакженетребуетдополнительныхотступов.
Выражения elifиelseтакже имеют двоеточие в конце логической строки,
закоторымследуютсоответствующиеблокикоманд(ссоответствующимчис-
ломотступов,конечно).
Внутриif-блокаоператора ifможетбытьдругойоператор ifитакдалее–это
называетсявложенным4оператором if.
Помните,чточасти elifиelseнеобязательны.Минимальнаякорректнаяза-
письоператора ifтакова:
ifTrue :
print ('Да, это верно. ')
После того, как Python заканчивает выполнение всего оператора ifвместе с
егочастями elifиelse,онпереходиткследующемувыражениювблоке,со-
держащем этот оператор if. В нашем случае это основной блок программы
(в котором начинается выполнение программы), а следующее выражение –
этоprint('Завершено') . После этого Python доходит до конца программы и
простовыходитизнеё.
Хотяэтоичрезвычайнопростаяпрограмма,яуказалвамнацелыйрядвещей,которые
стоитвзятьназаметку.Всёэтодовольнолегко(дажеудивительнолегкодлятехизвас,кто
пришёлизмираC/C++).Поначалувампридётсядержатьвсеэтивещивпамяти,нопосле
некоторойпрактикивыпривыкнете,ионивампокажутсявполне«естественными».
Замечание для программистов на C/C++
ВPythonнетоператора switch.Однако,припомощиконструкции if..elif..else можно
достичьтогожесамого(авнекоторыхслучаяхможнодажеиспользовать словарь,чтобы
сделатьэтобыстро).
9.2Оператор while
Оператор whileпозволяетмногократновыполнятьблоккоманддотехпор,покавыпол-
няетсянекотороеусловие.Этоодинизтакназываемых операторов цикла .Онтакжеможет
иметьнеобязательныйпункт else.
Пример: (сохранитекак while.py)
number =23
running =True
4nested– англ.«вложенный»( прим.перев. )
9.2. Оператор while 53
A Byte of Python (Russian), Версия 2.01
while running:
guess =int(input ('Введите целое число : '))
ifguess ==number:
print ('Поздравляю, вы угадали. ')
running =False # это останавливает цикл while
elif guess <number:
print ('Нет, загаданное число немного больше этого ')
else :
print ('Нет, загаданное число немного меньше этого. ')
else :
print ('Цикл while закончен. ')
# Здесь можете выполнить всё что вам ещё нужно
print ('Завершение. ')
Вывод:
$ python while.py
Введите целое число : 50
Нет, число несколько меньше.
Введите целое число : 22
Нет, число несколько больше.
Введите целое число : 23
Поздравляю, вы угадали.
Цикл while закончен.
Завершение.
Как это работает:
Вэтойпрограммемыпродолжаемигратьвигрусугадыванием,нопреиму-
щество состоит в том, что теперь пользователь может угадывать до тех пор,
пока не угадает правильное число, и ему не придётся запускать программу
заново для каждой попытки, как это происходило до сих пор. Это наглядно
демонстрируетприменениеоператора while.
Мыпереместилиоператоры inputиifвнутрьцикла whileиустановилипе-
ременную runningвзначение Trueпередзапускомцикла.Преждевсегопро-
веряется,равнолизначениепеременной running True ,азатемпроисходитпе-
реходксоответствующему while-блоку .Послевыполненияэтогоблокакоманд
условие,которымвданномслучаеявляетсяпеременная running,проверяется
снова. Если оно истинно, while-блок запускается снова, в противном случае
происходит переход к дополнительному else-блоку, а затем – к следующему
оператору.
Блок elseвыполняетсятогда,когдаусловиецикла whileстановитсяложным( False)–это
можетслучитьсядажеприсамойпервойпроверкеусловия.Еслиуцикла whileимеется
дополнительный блок else, он всегда выполняется, если только цикл не будет прерван
оператором break.
54 Глава 9. Поток команд
A Byte of Python (Russian), Версия 2.01
TrueиFalseназываются булевым типом данных, и вы можете считать их эквивалент-
нымизначениям 1и0соответственно.
Примечание для программистов на C/C++
Помните,чтоуцикла whileможетбытьблок else.
9.3Цикл for
Оператор for..inтакже является оператором цикла, который осуществляет итерацию
по последовательности объектов, т.е. проходит через каждый элемент в последователь-
ности. Мы узнаем больше о последовательностях в дальнейших главах, а пока просто
запомните,чтопоследовательность–этоупорядоченныйнаборэлементов.
Пример: (сохранитекак for.py)
for iinrange (1,5):
print (i)
else :
print ('Цикл for закончен ')
Вывод:
$ python for.py
1
2
3
4
Цикл for закончен
Как это работает:
Вэтойпрограммемывыводимнаэкран последовательность чисел.Мыгене-
рируемэтупоследовательность,используявстроеннуюфункцию range5.
Мы задаём два числа, и rangeвозвращает последовательность чисел от пер-
вогочисладовторого.Например, range(1,5) даётпоследовательность [1, 2,
3, 4]. По умолчанию rangeпринимает значение шага, равное 1. Если мы
зададим также и третье число range, оно будет служить шагом. Например,
range(1,5,2) даст [1,3]. Помните, интервал простирается только довторого
числа,т.е. невключаетеговсебя.
Обратите внимание, что range()генерирует последовательность чисел, но
только по одному числу за раз – когда оператор for запрашивает следую-
щий элемент. Чтобы увидеть всю последовательность чисел сразу, исполь-
зуйте list(range()) .Списки6подробнорассматриваютсявглаве Структуры
5range– англ.«диапазон»,«интервал»( прим.перев. )
6list– англ.«список»( прим.перев. )
9.3. Цикл for 55
A Byte of Python (Russian), Версия 2.01
данных.
Затем цикл forосуществляет итерацию по этому диапазону - for i in
range(1,5) эквивалентно for i in [1, 2, 3, 4] , что напоминает присва-
ивание переменной i по одному числу (или объекту) за раз, выполняя блок
команд для каждого значения i. В данном случае в блоке команд мы просто
выводимзначениенаэкран.
Помните,чтоблок elseнеобязателен.Еслионприсутствует,онвсегдавыполняетсяодин
разпослеокончанияцикла for,еслитольконеуказаноператор break.
Помнитетакже,чтоцикл for..inработаетдлялюбойпоследовательности.Внашемслу-
чаеэтосписокчисел,сгенерированныйвстроеннойфункцией range,новобщемслучае
можноиспользоватьлюбуюпоследовательностьлюбыхобъектов!Вследующихразделах
мыпознакомимсясэтимпоближе.
Примечание для программистов на C/C++/Java/C#
Цикл forв Python радикально отличается от цикла forв C/C++. Программисты на C#
заметят, что цикл forв Python похож на цикл foreachв C#. Программистам на Java это
можетнапомнитьконструкцию for (int i : IntArray) вJava1.5.
ЕсливC/C++записать for (int i = 0; i < 5; i++) ,товPythonэтомусоответствовалобы
выражение for i in range(0,5) .Каквидно,вPythonцикл forпроще,болеевыразителен
именееподверженошибкам.
9.4Оператор break
Оператор breakслужит для прерывания7цикла, т.е. остановки выполнения команд да-
жееслиусловиевыполненияциклаещёнепринялозначения Falseилипоследователь-
ностьэлементовнезакончилась.
Важноотметить,чтоеслициклы forили whileпрерватьоператором break,соответству-
ющиеимблоки elseвыполняться небудут.
Пример: (сохранитекак break.py)
while True :
s=input ('Введите что-нибудь : ')
ifs=='выход ':
break
print ('Длина строки: ',len(s))
print ('Завершение ')
Вывод:
7break– англ.«разбивать»,«разрывать»( прим.перев. )
56 Глава 9. Поток команд
A Byte of Python (Russian), Версия 2.01
$ python break.py
Введите что-нибудь : Программировать весело.
Длина строки: 23
Введите что-нибудь : Если работа скучна,
Длина строки: 19
Введите что-нибудь : Чтобы придать ей весёлый тон -
Длина строки: 30
Введите что-нибудь : используй Python!
Длина строки: 23
Введите что-нибудь : выход
Завершение
Как это работает:
Вэтойпрограммемымногократносчитываемпользовательскийвводивыво-
димнаэкрандлинукаждойвведённойстроки.Дляостановкипрограммымы
вводим специальное условие, проверяющее, совпадает ли пользовательский
ввод со строкой 'выход'. Мы останавливаем программу прерыванием цикла
оператором breakидостигаемеёконца.
Длинавведённойстрокиможетбытьнайденаприпомощивстроеннойфунк-
ции len.
Помнитетакже,чтооператор breakможетприменятьсяивцикле for.
9.4.1 Поэтический Python Swaroop’а
Длявводастрокздесьяиспользовалмини-стишок,которыйсамсочинил.Онназывается
Поэтический Python Swaroop’а8
Программироватьвесело.
Еслиработаскучна,
Чтобыпридатьейвесёлыйтон-
используйPython!
8
Swaroop’s Poetic Python :
Programmingisfun.
Whentheworkisdone,
ifyouwannamakeyourworkalsofun:
usePython!
9.4. Оператор break 57
A Byte of Python (Russian), Версия 2.01
9.5Оператор continue
Оператор continue используется для указания Python, что необходимо пропустить все
оставшиесякомандывтекущемблокециклаи продолжить9соследующейитерациицик-
ла.
Пример: (сохранитекак continue.py )
while True :
s=input ('Введите что-нибудь : ')
ifs=='выход ':
break
iflen(s) <3:
print ('Слишком мало ')
continue
print ('Введённая строка достаточной длины ')
# Разные другие действия здесь...
Вывод:
$ python continue.py
Введите что-нибудь : a
Слишком мало
Введите что-нибудь : 12
Слишком мало
Введите что-нибудь : абв
Введённая строка достаточной длины
Введите что-нибудь : выход
Как это работает:
Вэтойпрограммемызапрашиваемвводсостороныпользователя,нообраба-
тываем введённую строку только если она имеет длину хотя бы в 3 символа.
Итак,мыиспользуемвстроеннуюфункцию lenдляполучениядлиныстроки,
иеслидлинаменее3,мыпропускаемостальныедействиявблокеприпомо-
щиоператора continue.Впротивномслучаевсеостальныекомандывцикле
выполняются,производялюбыеманипуляции,которыенамнужны.
Заметьте,чтооператор continue такжеработаетисциклом for.
9.6Резюме
Мыувидели,какиспользоватьтриоператорадляуправленияпотокомкоманд: if,while
иfor,атакжесвязанныеснимиоператоры breakиcontinue.Этонаиболеечастоисполь-
зуемыеконструкцииPython,поэтомуовладетьимиоченьважно.
Далеемыувидим,каксоздаватьииспользоватьфункции.
9continue– англ.«продолжать»( прим.перев. )
58 Глава 9. Поток команд
Функции
Функции–этомногократноиспользуемыефрагментыпрограммы.Онипозволяютдать
имя определённому блоку команд с тем, чтобы в последствии запускать этот блок по
указанномуименивлюбомместепрограммыискольугодномногораз.Этоназывается
вызовомфункции.Мыужеиспользовалимноговстроенныхфункций,както lenиrange.
Функция – это, пожалуй, наиболее важный строительный блок любой нетривиальной
программы(налюбомязыкепрограммирования),поэтомувэтойглавемырассмотрим
различныеаспектыфункций.
Функции определяются при помощи зарезервированного слова def. После этого слова
указывается имяфункции, за которым следует пара скобок, в которых можно указать
имена некоторых переменных, и заключительное двоеточие в конце строки. Далее сле-
дуетблоккоманд,составляющихфункцию.Напримереможновидеть,чтонасамомделе
этооченьпросто:
Пример: (сохранитекак function1.py )
def sayHello ():
print ('Привет, Мир! ')# блок, принадлежащий функции
# Конец функции
sayHello() # вызов функции
sayHello() # ещё один вызов функции
Вывод:
$ python function1.py
Привет, Мир!
Привет, Мир!
Как это работает:
Мы определили функцию с именем sayHello, используя описанный выше
синтаксис.Этафункциянепринимаетпараметров,поэтомувскобкахнеобъ-
явлены какие-либо переменные. Параметры функции – это некие входные
данные,которыемыможемпередатьфункции,чтобыполучитьсоответству-
ющийимрезультат.
Обратите внимание, что мы можем вызывать одну и ту же функцию много
раз,азначитнетнеобходимостиписатьодинитотжекодсноваиснова.
59
A Byte of Python (Russian), Версия 2.01
10.1 Параметры функций
Функциимогутприниматьпараметры,т.е.некоторыезначения,передаваемыефункции
длятого,чтобыоначто-либо сделаласними.Этипараметрыпохожинапеременные,за
исключениемтого,чтозначениеэтихпеременныхуказываетсяпривызовефункции,и
вовремяработыфункцииимужеприсвоеныихзначения.
Параметры указываются в скобках при объявлении функции и разделяются запятыми.
Аналогично мы передаём значения, когда вызываем функцию. Обратите внимание на
терминологию:имена,указанныевобъявлениифункции,называются параметрами ,то-
гдакакзначения,которыевыпередаётевфункциюприеёвызове,– аргументами .
Пример: (сохранитекак func_param.py )
def printMax (a, b):
ifa>b:
print (a, 'максимально ')
elif a==b:
print (a, 'равно ', b)
else :
print (b, 'максимально ')
printMax( 3,4)# прямая передача значений
x=5
y=7
printMax(x, y) # передача переменных в качестве аргументов
Вывод:
$ python func_param.py
4 максимально
7 максимально
Как это работает:
Здесь мы определили функцию с именем printMax, которая использует два
параметра с именами aиb. Мы находим наибольшее число с применением
простогооператора if..else ивыводимэточисло.
Припервомвызовефункции printMax мынапрямуюпередаёмчиславкаче-
стве аргументов. Во втором случае мы вызываем функцию с переменными
в качестве аргументов. printMax(x, y) назначает значение аргумента xпа-
раметру a, а значение аргумента y– параметру b. В обоих случаях функция
printMax работаетодинаково.
60 Глава 10. Функции
A Byte of Python (Russian), Версия 2.01
10.2 Локальные переменные
Приобъявлениипеременныхвнутриопределенияфункции,ониникоимобразомнесвя-
заны с другими переменными с таким же именем за пределами функции – т.е. имена
переменныхявляются локальными вфункции.Этоназывается областью видимости пере-
менной.Областьвидимостивсехпеременныхограниченаблоком,вкоторомониобъяв-
лены,начинаясточкиобъявленияимени.
Пример: (сохранитекак func_local.py )
x=50
def func (x):
print ('x равен ', x)
x=2
print ('Замена локального x на ', x)
func(x)
print ('x по прежнему ', x)
Вывод:
$ python func_local.py
x равен 50
Замена локального x на 2
x по прежнему 50
Как это работает:
При первом выводе значения, присвоенного имени x, в первой строке функ-
цииPythonиспользуетзначениепараметра,объявленноговосновномблоке,
вышеопределенияфункции.
Далее мы назначаем xзначение 2. Имя xлокально для нашей функции. По-
этомукогдамызаменяемзначение xвфункции, x,объявленныйвосновном
блоке,остаётсянезатронутым.
Последнимвызовомфункции printмывыводимзначение x,указанноевос-
новном блоке, подтверждая таким образом, что оно не изменилось при ло-
кальномприсваиваниизначениявранеевызваннойфункции.
10.3 Зарезервированное слово «global»
Чтобы присвоить некоторое значение переменной, определённой на высшем уровне
программы(т.е.невкакой-либообластивидимости,кактофункциииликлассы),необ-
ходимоуказатьPython,чтоеёимянелокально,а глобально (global).Сделаемэтоприпомо-
щизарезервированногослова global.Безприменениязарезервированногослова global
невозможноприсвоитьзначениепеременной,определённойзапределамифункции.
10.2. Локальные переменные 61
A Byte of Python (Russian), Версия 2.01
Можно использовать уже существующие значения переменных, определённых за пре-
делами функции (при условии, что внутри функции не было объявлено переменной с
такимжеименем).Однако,этонеприветствуется,иегоследуетизбегать,посколькуче-
ловеку,читающемутекстпрограммы,будетнепонятно,гденаходитсяобъявлениепере-
менной. Использование зарезервированного слова globalдостаточно ясно показывает,
чтопеременнаяобъявленавсамомвнешнемблоке.
Пример: (сохранитекак func_global.py )
x=50
def func ():
global x
print ('x равно ', x)
x=2
print ('Заменяем глобальное значение x на ', x)
func()
print ('Значение x составляет ', x)
Вывод:
$ python func_global.py
x равно 50
Заменяем глобальное значение x на 2
Знчение x составляет 2
Как это работает:
Зарезервированноеслово globalиспользуетсядлятого,чтобыобъявить,что x
–этоглобальнаяпеременная,азначит,когдамыприсваиваемзначениеиме-
ниxвнутрифункции,этоизменениеотразитсяназначениипеременной xв
основномблокепрограммы.
Используя одно зарезервированное слово global, можно объявить сразу
несколькопеременных: global x, y, z .
10.4 Зарезервированное слово «nonlocal»
Мыувидели,какполучатьдоступкпеременнымвлокальнойиглобальнойобластиви-
димости.Естьещёодинтипобластивидимости,называемый«нелокальной»( nonlocal)
областью видимости, который представляет собой нечто среднее между первыми дву-
мя.Нелокальныеобластивидимостивстречаются,когдавыопределяетефункциивнутри
функций.
ПосколькувPythonвсёявляетсявыполнимымкодом,выможетеопределятьфункциигде
угодно.
62 Глава 10. Функции
A Byte of Python (Russian), Версия 2.01
Давайте рассмотрим пример:
# Filename: func_nonlocal.py
def func_outer ():
x=2
print ('x равно ', x)
def func_inner ():
nonlocal x
x=5
func_inner()
print ('Локальное x сменилось на ', x)
func_outer()
Вывод:
$ python func_nonlocal.py
x равно 2
Локальное x сменилось на 5
Как это работает:
Когда мы находимся внутри func_inner , переменная x, определённая в пер-
войстроке func_outer находитсянивлокальнойобластивидимости(опреде-
лениепеременнойневходитвблок func_inner ),нивглобальнойобластиви-
димости(онатакжеиневосновномблокепрограммы).Мыобъявляем,чтохо-
тим использовать именно эту переменную x, следующим образом: nonlocal
x.
Попробуйте заменить « nonlocal x » на « global x », а затем удалить это за-
резервированное слово, и пронаблюдайте за разницей между этими двумя
случаями.
10.5 Значения аргументов по умолчанию
Зачастую часть параметров функций могут быть необязательными , и для них будут ис-
пользоватьсянекоторыезаданныезначенияпоумолчанию,еслипользовательнеукажет
собственных.Этогоможнодостичьспомощьюзначенийаргументовпоумолчанию.Их
можноуказать,добавивкименипараметравопределениифункцииоператорприсваи-
вания( =)споследующимзначением.
Обратите внимание, что значение по умолчанию должно быть константой. Или точнее
говоря,онодолжнобытьнеизменным1–этообъясняетсяподробнеевпоследующихгла-
вах.Апоказапомнитеэто.
1«immutable»втерминологииPython( прим. перев. )
10.5. Значения аргументов по умолчанию 63
A Byte of Python (Russian), Версия 2.01
Пример: (сохранитекак func_default.py )
def say(message, times =1):
print (message *times)
say( 'Привет ')
say( 'Мир',5)
Вывод:
$ python func_default.py
Привет
МирМирМирМирМир
Как это работает:
Функцияподименем sayиспользуетсядлявыводанаэкранстрокиуказанное
числораз.Еслимынеуказываемзначения,поумолчаниюстрокавыводится
одинраз.Мыдостигаемэтогоуказаниемзначенияаргументапоумолчанию,
равного 1дляпараметра times2.
При первом вызове sayмы указываем только строку, и функция выводит её
одинраз.Привторомвызове sayмыуказываемтакжеиаргумент 5,обозначая
такимобразом,чтомыхотим сказать3фразу5раз.
Важно:Значениямипоумолчаниюмогутбытьснабженытолькопараметры,находящи-
есявконцеспискапараметров.Такимобразом,вспискепараметровфункциипараметр
созначениемпоумолчаниюнеможетпредшествоватьпараметрубеззначенияпоумол-
чанию. Это связано с тем, что значения присваиваются параметрам в соответствии с их
положением.Например, def func(a, b=5) допустимо,а def func(a=5, b) –не допусти-
мо.
10.6 Ключевые аргументы
Если имеется некоторая функция с большим числом параметров, и при её вызове тре-
буетсяуказатьтольконекоторыеизних,значенияэтихпараметровмогутзадаватьсяпо
ихимени–этоназывается ключевые параметры .Вэтомслучаедляпередачиаргументов
функциииспользуетсяимя(ключ)вместопозиции(какбылодосихпор).
Есть два преимущества такого подхода: во-первых, использование функции становится
легче,посколькунетнеобходимостиотслеживатьпорядокаргументов;во-вторых,можно
задавать значения только некоторым избранным аргументам, при условии, что осталь-
ныепараметрыимеютзначенияаргументапоумолчанию.
Пример: (сохранитекак func_key.py )
2times– англ.«раз»( прим. перев. )
3say– англ.«сказать»( прим. перев. )
64 Глава 10. Функции
A Byte of Python (Russian), Версия 2.01
def func (a, b =5, c=10):
print ('a равно ', a, ', b равно ', b, ', а c равно ', c)
func( 3,7)
func( 25, c=24)
func(c =50, a=100)
Вывод:
$ python func_key.py
a равно 3, b равно 7, а c равно 10
a равно 25, b равно 5, а c равно 24
a равно 100, b равно 5, а c равно 50
Как это работает:
Функциясименем funcимеетодинпараметрбеззначенияпоумолчанию,за
которымследуютдвапараметрасозначениямипоумолчанию.
Припервомвызове, func(3, 7) ,параметр aполучаетзначение 3,параметр b
получаетзначение 7,аcполучаетсвоёзначениепоумолчанию,равное 10.
Привторомвызове func(25, c=24) переменная aполучаетзначение25всилу
позицииаргумента.Послеэтогопараметр cполучаетзначение 24поимени,
т.е.какключевойпараметр.Переменная bполучаетзначениепоумолчанию,
равное 5.
При третьем обращении func(c=50, a=100) мы используем ключевые аргу-
менты для всех указанных значений. Обратите внимание на то, что мы ука-
зываем значение для параметра cперед значением для a, даже несмотря на
то,чтовопределениифункциипараметр aуказанраньше c.
10.7 Переменное число параметров4
Иногдабываетнужноопределитьфункцию,способнуюпринимать любоечислопарамет-
ров.Этогоможнодостичьприпомощизвёздочек(сохранитекак total.py):
def total (initial =5,*numbers, **keywords):
count =initial
for number innumbers:
count +=number
for key inkeywords:
count +=keywords[key]
return count
print (total( 10,1,2,3, vegetables =50, fruits =100))
4VarArgs– от англ.“Variablenumberof Argument s”–«переменноечислоаргументов»( прим. перев. )
10.7. Переменное число параметров 65
A Byte of Python (Russian), Версия 2.01
Вывод:
$ python total.py
166
Как это работает:
Когдамыобъявляемпараметрсозвёздочкой(например, *param),всепозици-
онныеаргументыначинаясэтойпозицииидоконцабудутсобранывкортеж
подименем param.
Аналогично,когдамыобъявляемпараметрысдвумязвёздочками( **param),
все ключевые аргументы начиная с этой позиции и до конца будут собраны
всловарьподименем param.
Мыизучимкортежиисловарив одной из последующих глав .
10.8 Только ключевые параметры
Еслинекоторыеключевыепараметрыдолжныбытьдоступнытолькопоключу,а некак
позиционныеаргументы,ихможнообъявитьпослепараметрасозвёздочкой(сохраните
какkeyword_only.py ):
def total (initial =5,*numbers, extra_number):
count =initial
for number innumbers:
count +=number
count +=extra_number
print (count)
total( 10,1,2,3, extra_number =50)
total( 10,1,2,3)
# Вызовет ошибку, поскольку мы не указали значение
# аргумента по умолчанию для 'extra_number'.
Вывод:
$ python keyword_only.py
66
Traceback (most recent call last):
File "keyword_only.py", line 12, in <module>
total(10, 1, 2, 3)
TypeError: total() needs keyword-only argument extra_number
Как это работает:
Объявлениепараметровпослепараметрасозвёздочкойдаёттолькоключевые
аргументы.Еслидлятакихаргументовнеуказанозначениепоумолчанию,и
оно не передано при вызове, обращение к функции вызовет ошибку, в чём
мытолькочтоубедились.
66 Глава 10. Функции
A Byte of Python (Russian), Версия 2.01
Обратитевниманиенаиспользование +=,которыйпредставляетсобойсокра-
щённый оператор, позволяющий вместо x = x + y просто написать x +=
y.
Есливамнужныаргументы,передаваемыетолькопоключу,ноненуженпа-
раметрсозвёздочкой,томожнопростоуказатьоднузвёздочкубезуказания
имени: def total(initial=5, *, extra_number) .
10.9 Оператор «return»
Оператор returnиспользуетсядлявозврата5изфункции,т.е.дляпрекращенияеёработы
ивыходаизнеё.Приэтомможнотакже вернуть некоторое значение изфункции.
Пример: (сохранитекак func_return.py )
#!/usr/bin/python
# Filename: func_return.py
def maximum (x, y):
ifx>y:
return x
elif x==y:
return 'Числа равны. '
else :
return y
print (maximum( 2,3))
Вывод:
$ python func_return.py
3
Как это работает:
Функция maximumвозвращает максимальный из двух параметров, которые в
данномслучаепередаютсяейпривызове.Онаиспользуетобычныйусловный
оператор if..else для определения наибольшего числа, а затем возвращает
эточисло.
Обратитевнимание,чтооператор returnбезуказаниявозвращаемогозначенияэквива-
лентенвыражению return None .None–этоспециальныйтипданныхвPython,обознача-
ющий ничего. К примеру, если значение переменной установлено в None, это означает,
чтоейнеприсвоеноникакогозначения.
Каждая функция содержит в неявной форме оператор return None в конце, если вы
не указали своего собственного оператора return. В этом можно убедиться, запустив
5return– англ.«возврат»( прим. перев. )
10.9. Оператор «return» 67
A Byte of Python (Russian), Версия 2.01
print(someFunction()) ,гдефункция someFunction –этокакая-нибудьфункция,неиме-
ющаяоператора returnвявномвиде.Например:
def someFunction ():
pass
Оператор passиспользуетсявPythonдляобозначенияпустогоблокакоманд.
Примечание: Существуетвстроеннаяфункция max,вкоторойужереализованфункци-
онал «поиск максимума», так что пользуйтесь этой встроенной функцией, где это воз-
можно.
10.10 Строки документации6
Python имеет остроумную особенность, называемую строками документации , обычно
обозначаемуюсокращённо docstrings.Этооченьважныйинструмент,которымвыобяза-
тельнодолжныпользоваться,посколькуонпомогаетлучшедокументироватьпрограм-
муиоблегчаетеёпонимание.Поразительно,нострокудокументацииможнополучить,
например,изфункции,дажевовремявыполненияпрограммы!
Пример: (сохранитекак func_doc.py )
def printMax (x, y):
'''Выводит максимальное из двух чисел.
Оба значения должны быть целыми числами.'''
x=int(x) # конвертируем в целые, если возможно
y=int(y)
ifx>y:
print (x, 'наибольшее ')
else :
print (y, 'наибольшее ')
printMax( 3,5)
print (printMax .__doc__)
Вывод:
$ python func_doc.py
5 наибольшее
Выводит максимальное из двух чисел.
Оба значения должны быть целыми числами.
6DocString- от англ.“Documentation String”–«строкадокументации»( прим. перев. )
68 Глава 10. Функции
A Byte of Python (Russian), Версия 2.01
Как это работает:
Строкавпервойлогическойстрокефункцииявляется строкой документации
дляэтойфункции.Обратитевниманиенато,чтострокидокументациипри-
менимытакжек модулямиклассам,окоторыхмыузнаемвсоответствующих
главах.
Строкидокументациипринятозаписыватьвформемногострочной7строки,
гдеперваястроканачинаетсясзаглавнойбуквыизаканчиваетсяточкой.Вто-
рая строка оставляется пустой, а подробное описание начинается с третьей.
Вам настоятельно рекомендуется следовать такому формату для всех строк
документациивсехвашихнетривиальныхфункций.
Доступ к строке документации функции printMax можно получить с помо-
щьюатрибутаэтойфункции(т.е.имени,принадлежащегоей) __doc__(обра-
тите внимание на двойное подчёркивание ). Просто помните, что Python пред-
ставляет всёввидеобъектов,включаяфункции.Мыузнаембольшеобобъек-
тахвглаве о классах.
Если вы пользовались функцией help()в Python, значит вы уже видели строки доку-
ментации. Эта функция просто-напросто считывает атрибут __doc__соответствующей
функциииаккуратновыводитегонаэкран.Выможетепроверитьеёнарассмотренной
вышефункции:простовключите help(printMax) втекстпрограммы.Незабудьтенажать
клавишу qдлявыходаизсправки( help).
Точно так же автоматические инструменты могут получать документацию из програм-
мы.Именнопоэтомуя настоятельно рекомендую вамиспользоватьстрокидокументации
для любой нетривиальной функции, которую вы пишете. Команда pydoc, поставляемая
вместеспакетомPython,работаетаналогичнофункции help().
10.11 Аннотации
Функцииимеютещёоднудополнительнуювозможность,называемуюаннотациями,ко-
торыепредоставляютотличныйспособсопровождениякаждогопараметра,равнокаки
возвращаемогозначениядополнительнойинформацией.ПосколькусамязыкPythonне
интерпретирует эти аннотации каким-либо способом (этот функционал отводится по-
стороннимбиблиотекам),мыопустимэтувозможностьизнашегообсуждения.Есливам
интереснопочитатьобаннотациях,просмотрите PEP 3107.
10.12 Резюме
Мы рассмотрели достаточно много аспектов функций, но тем не менее, вы должны по-
нимать,чтоэтодалеконевсеихаспекты.Втожевремя,мыохватилибольшинствотого,
счемвыбудетесталкиватьсяприповседневномиспользованиифункцийвPython.
7т.е.строки,содержащейсимволыпереводастроки.( прим. перев )
10.11. Аннотации 69
A Byte of Python (Russian), Версия 2.01
Далеемыувидим,какиспользоватьисоздаватьмодулиPython.
70 Глава 10. Функции
Модули
Как можно использовать код повторно, помещая его в функции, мы уже видели. А что,
еслинампонадобитсяповторноиспользоватьразличныефункциивдругихнашихпро-
граммах?Каквыуже,наверное,догадались,ответ–модули.
Существуютразныеспособысоставлениямодулей,носамыйпростой–этосоздатьфайл
срасширением .py,содержащийфункцииипеременные.
Другойспособ–написатьмодульнатомязыкепрограммирования,накоторомнаписан
сам интерпретатор Python. Например, можно писать модули на языке программирова-
нияC,которыепослекомпиляциимогутиспользоватьсястандартныминтерпретатором
Python.
Модуль можно импортировать в другую программу, чтобы использовать функции из
него.ТочнотакжемыиспользуемстандартнуюбиблиотекуPython.Сперва посмотрим,
какиспользоватьмодулистандартнойбиблиотеки.
Пример: (сохранитекак using_sys.py )
import sys
print ('Аргументы командной строки: ')
for iinsys.argv:
print (i)
print ('\n\nПеременная PYTHONPATH содержит ', sys .path, '\n')
Вывод:
$ python3 using_sys.py we are arguments
Аргументы командной строки:
using_sys.py
we
are
arguments
Переменная PYTHONPATH содержит ['', 'C:\\Windows\\system32\\python30.zip',
'C:\\Python30\\DLLs', 'C:\\Python30\\lib',
'C:\\Python30\\lib\\plat-win', 'C:\\Python30',
'C:\\Python30\\lib\\site-packages']
71
A Byte of Python (Russian), Версия 2.01
Как это работает:
В начале мы импортируем модуль sysкомандой import. Этим мы говорим
Python,чтохотимиспользоватьэтотмодуль.Модуль sysсодержитфункции,
относящиесякинтерпретаторуPythonиегосреде,т.е.к системе( system).
КогдаPythonвыполняеткоманду import sys ,онищетмодуль sys.Вданном
случаеэтоодинизвстроенныхмодулей,иPythonзнает,гдеегоискать.
Если бы это был не скомпилированный модуль, т.е. модуль, написанный на
Python,тогдаинтерпретаторPythonискалбыеговкаталогах,перечисленныхв
переменной sys.path.Еслимодульнайден,выполняютсякомандывтелемо-
дуля, и он становится доступным . Обратите внимание, что инициализация1
происходиттолькопри первомимпортемодуля.
Доступкпеременной argvвмодуле sysпредоставляетсяприпомощиточки,
т.е.sys.argv. Это явно показывает, что это имя является частью модуля sys.
Ещёоднимпреимуществомтакогообозначенияявляетсято,чтоимянекон-
фликтуетсименемпеременной argv,котораяможетиспользоватьсяввашей
программе.
Переменная sys.argv является спискомстрок (списки будут детально обсуж-
датьсяв одной из последующих глав ).Онасодержитсписок аргументов команд-
ной строки ,т.е.аргументов,переданныхпрограммеизкоманднойстроки.
Если вы используете среду разработки2для написания и запуска программ,
поищите где-нибудь в её меню возможность передавать параметры команд-
нойстроки.
В нашем примере, когда мы запускаем “ python using_sys.py we are
arguments ”, мы запускаем модуль using_sys.py командой python, а всё, что
следует далее – аргументы, передаваемые программе3. Python сохраняет ар-
гументыкоманднойстрокивпеременной sys.argv длядальнейшегоисполь-
зования.
Помните, что имя запускаемого сценария4всегда является первым аргумен-
том в списке sys.argv. Так что в приведённом примере 'using_sys.py'
будет элементом sys.argv[0] ,'we'–sys.argv[1] ,'are'–sys.argv[2] , а
'arguments' –sys.argv[3] . Помните, что в Python нумерация начинается с
0,анес1.
sys.path содержит список имён каталогов, откуда импортируются модули.
Заметьте, что первая строка в sys.path пуста; эта пустая строка показывает,
что текущая директория также является частью sys.path, которая совпадает
со значением переменной окружения PYTHONPATH . Это означает, что модули,
1Инициализация–ряддействий,производимыхприначальнойзагрузке( прим. перев. )
2IDE- от англ.“IntegratedDevelopmentEnvironment”–«интегрированнаясредаразработки»( прим. пе-
рев.)
3“wearearguments”- англ.«мыаргументы»( прим. перев. )
4Программунаинтерпретируемомязыкепрограммированиятакженазывают сценарием или скриптом
(прим. перев. )
72 Глава 11. Модули
A Byte of Python (Russian), Версия 2.01
расположенныевтекущемкаталоге,можноимпортироватьнапрямую.Впро-
тивномслучаепридётсяпоместитьсвоймодульводинизкаталогов,перечис-
ленныхв sys.path.
Помните, что текущий каталог – это каталог, в котором была запущена про-
грамма.Выполните import os; print(os.getcwd()) ,чтобыузнатьтекущий
каталогпрограммы.
11.1 Файлы байткода .pyc
Импорт модуля – относительно дорогостоящее мероприятие, поэтому Python предпри-
нимает некоторые трюки для ускорения этого процесса. Один из способов – создать
байт-компилированные файлы (или байткод) с расширением .pyc, которые являются
некойпромежуточнойформой,вкоторуюPythonпереводитпрограмму(помнитераздел
“Введение” отом,какработаетPython?).Такойфайл .pycполезенприимпортемодуляв
следующийразвдругуюпрограмму–этопроизойдётнамногобыстрее,посколькузна-
чительная часть обработки, требуемой при импорте модуля, будет уже проделана. Этот
байткодтакжеявляетсяплатформо-независимым.
Примечание: Обычнофайлы .pycсоздаютсявтомжекаталоге,гдерасположеныисоот-
ветствующиеимфайлы .py.ЕслиPythonнеможетполучитьдоступдлязаписифайлов
вэтоткаталог,файлы .pycсозданынебудут.
11.2 Оператор from ... import ...
Чтобыимпортироватьпеременную argvпрямовпрограммуинеписатьвсякийраз sys.
приобращениикней,можновоспользоватьсявыражением“ from sys import argv ”.
Дляимпортавсехимён,использующихсявмодуле sys,можновыполнитькоманду“ from
sys import * ”.Этоработаетдлялюбыхмодулей.
В общем случае вам следует избегать использования этого оператора и использовать
вместо этого оператор import, чтобы предотвратить конфликты имён и не затруднять
чтениепрограммы.
Пример:
from math import *
n=input ("Введите диапазон:- ")
p=[2,3]
count =2
a=5
while (count <n):
b=0
for iinrange (2,a):
11.1. Файлы байткода .pyc 73
A Byte of Python (Russian), Версия 2.01
if( i <=sqrt(a)):
if(a%i==0):
print ("a neprost ",a)
b=1
else :
pass
if(b!=1):
print ("a prost ",a)
p=p+[a]
count =count +1
a=a+2
print p
11.3 Имя модуля – __name__
Укаждогомодуляестьимя,икомандывмодулемогутузнатьимяихмодуля.Этополез-
но,когданужнознать,запущенлимодулькаксамостоятельнаяпрограммаилиимпорти-
рован.Какужеупоминалосьвыше,когдамодульимпортируетсявпервые,содержащийся
в нём код исполняется. Мы можем воспользоваться этим для того, чтобы заставить мо-
дуль вести себя по-разному в зависимости от того, используется ли он сам по себе или
импортируетсявдругуюпрограмма.Этогоможнодостичьсприменениематрибутамо-
дуляподназванием __name__.
Пример: (сохранитекак using_name.py )
if__name__ =='__main__ ':
print ('Эта программа запущена сама по себе. ')
else :
print ('Меня импортировали в другой модуль. ')
Вывод:
$ python3 using_name.py
Эта программа запущена сама по себе.
$ python3
>>> import using_name
Меня импортировали в другой модуль.
>>>
Как это работает:
В каждом модуле Python определено его имя – __name__5. Если оно равно
'__main__' ,этоозначает,чтомодульзапущенсамостоятельнопользователем,
имыможемвыполнитьсоответствующиедействия.
5name- англ.«имя»( прим. перев. )
74 Глава 11. Модули
A Byte of Python (Russian), Версия 2.01
11.4 Создание собственных модулей
Создатьсобственныймодульоченьлегко.Давывсёвремяделалиэто!Ведькаждаяпро-
грамманаPythonтакжеявляетсяимодулем.Необходимолишьубедиться,чтоунеёуста-
новленорасширение .py.Следующийпримеробъяснитэто.
Пример: (сохранитекак mymodule.py )
def sayhi ():
print ('Привет! Это говорит мой модуль. ')
__version__ ='0.1'
# Конец модуля mymodule.py
Вышеприведёнпростой модуль.Каквидно,внёмнетничегоособенногопосравнениюс
обычнойпрограммойнаPython.Далеепосмотрим,какиспользоватьэтотмодульвдру-
гихнашихпрограммах.
Помните,чтомодульдолженнаходитьсялибовтомжекаталоге,чтоипрограмма,вко-
торуюмыимпортируемего,либоводномизкаталогов,указанныхв sys.path.
Ещёодинмодуль(сохранитекак mymodule_demo.py ):
import mymodule
mymodule .sayhi()
print ('Версия ', mymodule .__version__)
Вывод:
$ python mymodule_demo.py
Привет! Это говорит мой модуль.
Версия 0.1
Как это работает:
Обратитевнимание,чтомыиспользуемвсётожеобозначениеточкойдлядо-
ступакэлементаммодуля.Pythonповсеместноиспользуетодноитожеобо-
значение точкой, придавая ему таким образом характерный «Python-овый»
видиневынуждаянасизучатьвсёновыеиновыеспособыделатьчто-либо.
Вотверсия,использующаясинтаксис from..import (сохранитекак mymodule_demo2.py ):
from mymodule import sayhi, __version__
sayhi()
print ('Версия ', __version__)
Вывод mymodule_demo2.py такойже,каки mymodule_demo.py .
11.4. Создание собственных модулей 75
A Byte of Python (Russian), Версия 2.01
Обратитевнимание,чтоесливмодуле,импортирующемданныймодуль,ужебылообъ-
явлено имя __version__ , возникнет конфликт. Это весьма вероятно, так как объявлять
версию любого модуля при помощи этого имени – общепринятая практика. Поэтому
всегдарекомендуетсяотдаватьпредпочтениеоператору import,хотяэтоисделаетвашу
программунемногодлиннее.
Вымоглибытакжеиспользовать:
from mymodule import *
Этоимпортируетвсепубличныеимена,такиекак sayhi,нонеимпортирует __version__ ,
потомучтоононачинаетсясдвойногоподчёркивания
Дзэн Python
ОднимизруководящихпринциповвPythonявляется«ЯвноелучшеНеявного».Выпол-
нитекоманду“ import this ”,чтобыузнатьбольше,атакжепросмотрите этообсуждение ,
вкоторомприводятсяпримерыпокаждомуизпринципов.
11.5 Функция dir
Выможетеиспользоватьвстроеннуюфункцию dir,чтобыполучитьсписокидентифика-
торов,которыеобъектопределяет.Таквчислоидентификаторовмодулявходятфункции,
классыипеременные,определённыевэтоммодуле.
Когда вы передаёте функции dir()имя модуля, она возвращает список имён, опреде-
лённыхвэтоммодуле.Еслиникакогоаргументанепередавать,онавернётсписокимён,
определённыхвтекущеммодуле.
Пример:
$ python3
>>> import sys # получим список атрибутов модуля 'sys'
>>> dir(sys)
['__displayhook__', '__doc__', '__excepthook__', '__name__', '__package__', '__s
tderr__', '__stdin__', '__stdout__', '_clear_type_cache', '_compact_freelists',
'_current_frames', '_getframe', 'api_version', 'argv', 'builtin_module_names', '
byteorder', 'call_tracing', 'callstats', 'copyright', 'displayhook', 'dllhandle'
, 'dont_write_bytecode', 'exc_info', 'excepthook', 'exec_prefix', 'executable',
'exit', 'flags', 'float_info', 'getcheckinterval', 'getdefaultencoding', 'getfil
esystemencoding', 'getprofile', 'getrecursionlimit', 'getrefcount', 'getsizeof',
'gettrace', 'getwindowsversion', 'hexversion', 'intern', 'maxsize', 'maxunicode
', 'meta_path', 'modules', 'path', 'path_hooks', 'path_importer_cache', 'platfor
m', 'prefix', 'ps1', 'ps2', 'setcheckinterval', 'setprofile', 'setrecursionlimit
', 'settrace', 'stderr', 'stdin', 'stdout', 'subversion', 'version', 'version_in
76 Глава 11. Модули
A Byte of Python (Russian), Версия 2.01
fo', 'warnoptions', 'winver']
>>> dir() # получим список атрибутов текущего модуля
['__builtins__', '__doc__', '__name__', '__package__', 'sys']
>>> a = 5 # создадим новую переменную 'a'
>>> dir()
['__builtins__', '__doc__', '__name__', '__package__', 'a', 'sys']
>>> del a # удалим имя 'a'
>>> dir()
['__builtins__', '__doc__', '__name__', '__package__', 'sys']
>>>
Как это работает:
Сперва мы видим результат применения dirк импортированному модулю
sys.Видимогромныйсписокатрибутов,содержащихсявнём.
Затем мы вызываем функцию dir, не передавая ей параметров. По умолча-
нию,онавозвращаетсписокатрибутовтекущегомодуля.Обратитевнимание,
чтосписокимпортированныхмодулейтакжевходиттуда.
Чтобы пронаблюдать за действием dir, мы определяем новую переменную
aи присваиваем ей значение, а затем снова вызываем dir. Видим, что в
полученном списке появилось дополнительное значение. Удалим перемен-
ную/атрибут из текущего модуля при помощи оператора del, и изменения
вновьотобразятсянавыводефункции dir.
Замечаниепоповоду del:этотоператориспользуетсядля удаленияперемен-
ной/имени,ипослееговыполнения,вданномслучае– del a,кпеременной
aбольшеневозможнообратиться–еёкакбудтоникогдаинебыло.
Обратите внимание, что функция dir()работает для любогообъекта. Напри-
мер,выполните“ dir('print') ”,чтобыувидетьатрибутыфункции print,или
“dir(str)”,чтобыувидетьатрибутыкласса str.
11.6 Пакеты
К настоящему времени вы, вероятно, начали наблюдать некоторую иерархию в органи-
зациивашихпрограмм.Переменныеобычнонаходятсявфункциях.Функциииглобаль-
ныепеременныеобычнонаходятсявмодулях.Ачто,есливозникнетнеобходимостькак-
тоорганизоватьмодули?Вотздесь-тоивыходятнасценупакеты.
Пакеты–этопростокаталогисмодулямииспециальнымфайлом __init__.py ,который
показываетPython,чтоэтоткаталогособый,таккаксодержитмодулиPython.
11.6. Пакеты 77
A Byte of Python (Russian), Версия 2.01
Представим, что мы хотим создать пакет под названием «world» с субпакетами «asia»,
«africa»ит.д.,которые,всвоюочередь,будутсодержатьмодули«india»,«madagascar»и
т.д.
Дляэтогоследовалобысоздатьследующуюструктурукаталогов:
| - <некоторый каталог из sys.path>/
| |---- world/
| |---- __init__.py
| |---- asia/
| | |---- __init__.py
| | |---- india/
| | |---- __init__.py
| | |---- foo.py
| |---- africa/
| |---- __init__.py
| |---- madagascar/
| |---- __init__.py
| |---- bar.py
Пакеты – это удобный способ иерархически организовать модули. Такое часто встреча-
етсяв стандартной библиотеке .
11.7 Резюме
Точно так же, как функции являются многократно используемыми фрагментами про-
грамм,модулиявляютсямногократноиспользуемымипрограммами.Пакеты–этоспо-
собиерархическойорганизациимодулей.СтандартнаябиблиотекаPythonявляетсяпри-
меромтакогонаборапакетовимодулей.
Мыувидели,какпользоватьсяэтимимодулямиисоздаватьсвои.
Далее мы познакомимся с некоторыми интересными концепциями, называемыми
«структурыданных».
78 Глава 11. Модули
Структуры данных
Структурыданных–это,посути,иесть структуры ,которыемогутхранитьнекоторые
данныевместе.Другимисловами,онииспользуютсядляхранениясвязанныхданных.
В Python существуют четыре встроенных структуры данных: список, кортеж, словарь и
множество.Посмотрим,какимипользоваться,икаконимогутоблегчитьнамжизнь.
12.1 Список
Список1–этоструктураданных,котораясодержитупорядоченныйнаборэлементов,т.е.
хранит последовательность элементов. Это легко представить, если вспомнить список
покупок, в котором перечисляется, что нужно купить, с тем лишь исключением, что в
списке покупок каждый элемент обычно размещается на отдельной строке, тогда как в
Pythonониразделяютсязапятыми.
Списокэлементовдолженбытьзаключёнвквадратныескобки,чтобыPythonпонял,что
это список. Как только список создан, можно добавлять, удалять или искать элементы
в нём. Поскольку элементы можно добавлять и удалять, мы говорим, что список – это
изменяемый типданных,т.е.егоможномодифицировать.
12.2 Краткое введение в объекты и классы
Хотяяистаралсядосихпороттянутьобсуждениеобъектовиклассов,наданномэтапевсё
женеобходимонекотороепояснение,чтобывылучшепонялиидеюсписков.Мыизучим
этутемудетальнов её собственной главе .
Список–этоодинизпримеровиспользованияобъектовиклассов.Когдамыназначаем
некоторой переменной iзначение, скажем, целое число 5, это можно представить себе
как создание объекта(т.е. экземпляра) iкласса(т.е. типа) int. Чтобы лучше понять это,
прочитайте help(int) .
Классможеттакжеиметь методы,т.е.функции,определённыедляиспользованиятолько
применительнокданномуклассу.Этотфункционалбудетдоступентолькокогдаимеет-
сяобъектданногокласса.Например,Pythonпредоставляетметод appendдлякласса list,
который позволяет добавлять элемент к концу списка. Так mylist.append('and item')
1list– англ.«список»( прим.перев. )
79
A Byte of Python (Russian), Версия 2.01
добавитэтустрокуксписку mylist.Обратитевниманиенаобозначениеточкойдлядо-
ступакметодамобъектов.
Класс также может иметь поля, которые представляют собой не что иное, как перемен-
ные,определённыедляиспользованиятолькоприменительнокданномуклассу.Этипе-
ременные/имена можно использовать только тогда, когда имеется объект этого класса.
Доступкполямтакжеосуществляетсяприпомощиточки.Например, mylist.field .
Пример: (сохранитекак using_list.py )
# Это мой список покупок
shoplist =['яблоки ','манго ','морковь ','бананы ']
print ('Я должен сделать ',len(shoplist), 'покупок. ')
print ('Покупки: ', end ='')
for item inshoplist:
print (item, end ='')
print ('\nТакже нужно купить риса. ')
shoplist .append( 'рис')
print ('Теперь мой список покупок таков: ', shoplist)
print ('Отсортирую-ка я свой список ')
shoplist .sort()
print ('Отсортированный список покупок выглядит так: ', shoplist)
print ('Первое, что мне нужно купить, это ', shoplist[ 0])
olditem =shoplist[ 0]
del shoplist[ 0]
print ('Я купил ', olditem)
print ('Теперь мой список покупок: ', shoplist)
Вывод:
$ python3 using_list.py
Я должен сделать 4 покупок.
Покупки: яблоки манго морковь бананы
Также нужно купить риса.
Теперь мой список покупок таков: ['яблоки', 'манго', 'морковь', 'бананы', 'рис']
Отсортирую-ка я свой список
Отсортированный список покупок выглядит так: ['бананы', 'манго', 'морковь', 'рис',
'яблоки']
Первое, что мне нужно купить, это бананы
Я купил бананы
Теперь мой список покупок: ['манго', 'морковь', 'рис', 'яблоки']
Как это работает:
80 Глава 12. Структуры данных
A Byte of Python (Russian), Версия 2.01
Переменная shoplist – это список покупок человека, идущего на рынок. В
shoplist мыхранимтолькострокисназваниямитого,чтонужнокупить,од-
наковсписокможнодобавлять любые объекты ,включаячислаилидажедру-
гиесписки.
Мы также использовали цикл for..inдля итерации по элементам списка.
Выуже,наверное,поняли,чтосписокявляетсятакжеипоследовательностью.
Особенностипоследовательностейбудутрассмотрены ниже.
Обратите внимание на использование ключевого аргумента endв функции
print,которыйпоказывает,чтомыхотимзакончитьвыводпробеломвместо
обычногопереводастроки.
Далеемыдобавляемэлементкспискуприпомощи append–методаобъекта
списка, который уже обсуждался ранее. Затем мы проверяем, действительно
ли элемент был добавлен к списку, выводя содержимое списка на экран при
помощи простой передачи этого списка функции print, которая аккуратно
егопечатает.
Затеммысортируемсписок,используяметод sortобъектасписка.Имейтев
виду, что этот метод действует на сам список, а не возвращает изменённую
еговерсию.Вэтомотличиеоттого,какпроисходитработасостроками.Имен-
но это имеется в виду, когда мы говорим, что списки изменяемы , а строки –
неизменяемы .
Далеепослесовершенияпокупкимыхотимудалитьеёизсписка.Этодости-
гаетсяприменениемоператора del.Мыуказываем,какойэлементспискамы
хотимудалить,иоператор delудаляетего.Мыуказываем,чтохотимудалить
первый элемент списка, и поэтому пишем “ del shoplist[0] ” (помните, что
Pythonначинаетотсчётс0).
Чтобыузнатьболеедетальнообовсехметодахобъектасписка,просмотрите help(list) .
12.3 Кортеж
Кортежислужатдляхранениянесколькихобъектоввместе.Ихможнорассматриватькак
аналогсписков,нобезтакойобширнойфункциональности,которуюпредоставляеткласс
списка.Однаизважнейшихособенностейкортежейзаключаетсявтом,чтоони неизме-
няемы,также,какистроки.Т.е.модифицироватькортежиневозможно.
Кортежи обозначаются указанием элементов, разделённых запятыми; по желанию их
можноещёзаключитьвкруглыескобки.
Кортежиобычноиспользуютсявтехслучаях,когдаоператорилипользовательскаяфунк-
циядолжнынаверняказнать,чтонаборзначений,т.е.кортежзначений,неизменится.
Пример: (сохранитекак using_tuple.py )
zoo =('питон ','слон ','пингвин ')# помните, что скобки не обязательны
print ('Количество животных в зоопарке - ',len(zoo))
12.3. Кортеж 81
A Byte of Python (Russian), Версия 2.01
new_zoo ='обезьяна ','верблюд ', zoo
print ('Количество клеток в зоопарке - ',len(new_zoo))
print ('Все животные в новом зоопарке: ', new_zoo)
print ('Животные, привезённые из старого зоопарка: ', new_zoo[ 2])
print ('Последнее животное, привезённое из старого зоопарка - ', new_zoo[ 2][2])
print ('Количество животных в новом зоопарке - ',len(new_zoo) -1+len(new_zoo[ 2]))
Вывод:
$ python3 using_tuple.py
Количество животных в зоопарке - 3
Количество клеток в зоопарке - 3
Все животные в новом зоопарке: ('обезьяна', 'верблюд', ('питон', 'слон',
'пингвин'))
Животные, привезённые из старого зоопарка: ('питон', 'слон', 'пингвин')
Последнее животное, привезённое из старого зоопарка - пингвин
Количество животных в новом зоопарке - 5
Как это работает:
Переменная zooобозначает кортеж элементов. Как мы видим, функция len
позволяет получить длину кортежа. Это также указывает на то, что кортеж
является последовательностью .
Теперь мы перемещаем этих животных в новый зоопарк, поскольку старый
зоопаркзакрывается.Поэтомукортеж new_zooсодержиттехживотных,кото-
рыеужетам,нарядуспривезённымиизстарогозоопарка.Возвращаяськре-
альности,обратитевниманиенато,чтокортежвнутрикортежанетеряетсво-
ейиндивидуальности.
Доступ к элементам кортежа осуществляется указанием позиции элемента,
заключённойвквадратныескобки–точнотакже,какмыэтоделалидляспис-
ков. Это называется оператором индексирования . Доступ к третьему элементу
вnew_zooмы получаем, указывая new_zoo[2] , а доступ к третьему элементу
внутри третьего элемента в кортеже new_zoo– указывая new_zoo[2][2] . Это
достаточнопросто,кактольковыпоймётепринцип.
Скобки
Хотя скобки и не являются обязательными, я предпочитаю всегда указывать их, что-
бы было очевидно, что это кортеж, особенно в двусмысленных случаях. Например,
“print(1,2,3) ” и “ print( (1,2,3) ) ” делают разные вещи: первое выражение выводит
тричисла,тогдакаквторое–кортеж,содержащийэтитричисла.
Кортеж, содержащий 0 или 1 элемент
Пустой кортеж создаётся при помощи пустой пары скобок – “ myempty = () ”. Однако, с
кортежем из одного элемента не всё так просто. Его нужно указывать при помощи за-
82 Глава 12. Структуры данных
A Byte of Python (Russian), Версия 2.01
пятой после первого (и единственного) элемента, чтобы Python мог отличить кортежот
скобок, окружающих объект в выражении. Таким образом, чтобы получить кортеж, со-
держащийэлемент 2,вампотребуетсяуказать“ singleton = (2,) ”.
Замечание для программистов на Perl
Списоквнутрисписканетеряетсвоейиндивидуальности,т.е.спискинеразвёртываются,
каквPerl.Этожеотноситсяккортежувнутрикортежа,иликортежувнутрисписка,или
спискувнутрикортежаит.д.ВPythonвсеонирассматриваютсякакобъекты,хранящиеся
внутридругогообъекта–толькоивсего.
12.4 Словарь
Словарь–этонекийаналогадреснойкниги,вкоторойможнонайтиадресиликонтакт-
нуюинформациюочеловеке,знаялишьегоимя;т.е.некоторые ключи(имена)связаны
созначениями (информацией).Заметьте,чтоключдолженбытьуникальным–выведь
несможетеполучитькорректнуюинформацию,еслиувасзаписаныдвачеловекаспол-
ностьюодинаковымиименами.
Обратитетакжевниманиенато,чтовсловаряхвкачествеключеймогутиспользоваться
только неизменяемые объекты (как строки), а в качестве значений можно использовать
какнеизменяемые,такиизменяемыеобъекты.Точнееговоря,вкачествеключейдолжны
использоватьсятолькопростыеобъекты.
Парыключ-значениеуказываютсявсловареследующимобразом:“ d = {key1 : value1,
key2 : value2 } ”.Обратитевнимание,чтоключизначениеразделяютсядвоеточием,а
парыдруготдругаотделяютсязапятыми,азатемвсёэтозаключаетсявфигурныескобки.
Помните,чтопарыключ-значениеникоимобразомнеупорядоченывсловаре.Есливам
необходимнекоторыйпорядок,вампридётсяотдельноотсортироватьсловарьпередоб-
ращениемкнему.
Словариявляютсяэкземплярами/объектамикласса dict.
Пример: (сохранитекак using_dict.py )
# 'ab' - сокращение от 'a'ddress'b'ook
ab={'Swaroop ' :'swaroop@swaroopch.com ',
'Larry ' :'larry@wall.org ',
'Matsumoto ':'matz@ruby-lang.org ',
'Spammer ' :'spammer@hotmail.com '
}
print ("Адрес Swaroop 'а:", ab[ 'Swaroop '])
# Удаление пары ключ-значение
12.4. Словарь 83
A Byte of Python (Russian), Версия 2.01
del ab['Spammer ']
print ('\nВ адресной книге {0} контактов \n'.format( len(ab)))
for name, address inab.items():
print ('Контакт {0} с адресом {1} '.format(name, address))
# Добавление пары ключ-значение
ab['Guido ']='guido@python.org '
if'Guido 'inab:
print ("\nАдрес Guido: ", ab[ 'Guido '])
Вывод:
$ python3 using_dict.py
Адрес Swaroop'а: swaroop@swaroopch.com
В адресной книге 3 контактов
Контакт Swaroop с адресом swaroop@swaroopch.com
Контакт Matsumoto с адресом matz@ruby-lang.org
Контакт Larry с адресом larry@wall.org
Адрес Guido: guido@python.org
Как это работает:
Мы создаём словарь ab2при помощи обозначений, описанных ранее. Затем
мы обращаемся к парам ключ-значение, указывая ключ в операторе индек-
сирования, которым мы пользовались для списков и кортежей. Как видите,
синтаксиспрост.
Удалять пары ключ-значение можно при помощи нашего старого доброго
оператора del. Мы просто указываем имя словаря и оператор индексирова-
ния для удаляемого ключа, после чего передаём это оператору del. Для этой
операции нет необходимости знать, какое значение соответствует данному
ключу.
Далеемыобращаемсяковсемпарамключ-значениенашегословаря,исполь-
зуя метод items, который возвращает список кортежей, каждый из которых
содержитпаруэлементов:ключизначение.Мыполучаемэтупаруиприсваи-
ваемеёзначениепеременным nameиaddressсоответственновцикле for..in,
азатемвыводимэтизначениянаэкранвблокеfor.
Новые пары ключ-значение добавляются простым обращением к нужному
ключу при помощи оператора индексирования и присваиванием ему неко-
торогозначения,какмысделалидляGuidoвпримеревыше.
2address book– англ.«адреснаякнига»( прим. перев. )
84 Глава 12. Структуры данных
A Byte of Python (Russian), Версия 2.01
Проверить,существуетлипараключ-значение,можноприпомощиоперато-
раin.
Чтобыпросмотретьсписоквсехметодовкласса dictсмотрите help(dict) .
Ключевые Аргументы и Словари
Кслову,есливыиспользовалиключевыеаргументыввашихфункциях,выужеисполь-
зовали словари! Только подумайте: вы указали пару ключ-значение среди параметров
функции при её определении, а когда обращаетесь к переменным внутри функции, то
это, фактически, обращение по ключу к словарю (который в терминах разработчиков
компиляторовназывается таблицей имён ).
12.5 Последовательности
Списки, кортежи и строки являются примерами последовательностей. Но что такое по-
следовательностиичтовнихтакогоособенного?
Основныевозможности–это проверка принадлежности (т.е.выражения“ in”и“not in”)
иоператор индексирования ,позволяющийполучитьнапрямуюнекоторыйэлементпо-
следовательности.
Все три типа последовательностей, упоминавшиеся выше (списки, кортежи и строки),
такжепредоставляютоперациюполучения вырезки,котораяпозволяетполучитьвырез-
купоследовательности,т.е.еёфрагмент.
Пример: (сохранитекак seq.py)
shoplist =['яблоки ','манго ','морковь ','бананы ']
name ='swaroop '
# Операция индексирования
print ('Элемент 0 - ', shoplist[ 0])
print ('Элемент 1 - ', shoplist[ 1])
print ('Элемент 2 - ', shoplist[ 2])
print ('Элемент 3 - ', shoplist[ 3])
print ('Элемент -1 - ', shoplist[ -1])
print ('Элемент -2 - ', shoplist[ -2])
print ('Символ 0 - ', name[ 0])
# Вырезка из списка
print ('Элементы с 1 по 3: ', shoplist[ 1:3])
print ('Элементы с 2 до конца: ', shoplist[ 2:])
print ('Элементы с 1 по -1: ', shoplist[ 1:-1])
print ('Элементы от начала до конца: ', shoplist[:])
# Вырезка из строки
12.5. Последовательности 85
A Byte of Python (Russian), Версия 2.01
print ('Символы с 1 по 3: ', name[ 1:3])
print ('Символы с 2 до конца: ', name[ 2:])
print ('Символы с 1 до -1: ', name[ 1:-1])
print ('Символы от начала до конца: ', name[:])
Вывод:
$ python3 seq.py
Элемент 0 - яблоки
Элемент 1 - манго
Элемент 2 - морковь
Элемент 3 - бананы
Элемент -1 - бананы
Элемент -2 - морковь
Символ 0 - s
Элементы с 1 по 3: ['манго', 'морковь']
Элементы с 2 до конца: ['морковь', 'бананы']
Элементы с 1 по -1: ['манго', 'морковь']
Элементы от начала до конца: ['яблоки', 'манго', 'морковь', 'бананы']
Символы с 1 по 3: wa
Символы с 2 до конца: aroop
Символы с 1 до -1: waroo
Символы от начала до конца: swaroop
Как это работает:
Преждевсего,мывидим,какиспользоватьиндексыдляполученияотдельных
элементовпоследовательности.Этоещёназывают приписыванием индекса .Ко-
гдамыуказываемчисловквадратныхскобкахпослепоследовательности,как
показановыше,Pythonизвлекаетэлемент,соответствующийуказаннойпози-
циивпоследовательности.Помните,чтоPythonначинаетотсчётс0.Поэтому
shoplist[0] извлекает первый элемент, а shoplist[3] – четвёртый элемент
последовательности shoplist.
Индекстакжеможетбытьотрицательнымчислом.Вэтомслучаепозицияот-
считывается от конца последовательности. Поэтому shoplist[-1] указыва-
ет на последний элемент последовательности shoplist, аshoplist[-2] – на
предпоследний.
Операция вырезки производится при помощи указания имени последова-
тельности,закоторымможетследоватьпарачисел,разделённыхдвоеточием
и заключённых в квадратные скобки. Заметьте, как это похоже на операцию
индексирования,котороймыпользовалисьдосихпор.Помните,чточислав
скобкахнеобязательны,тогдакакдвоеточие–обязательно.
Первоечисло(переддвоеточием)воперациивырезкиуказываетпозицию,с
которойвырезкадолжнаначинаться,автороечисло(последвоеточия)указы-
вает, где вырезка должна закончиться. Если первое число не указано, Python
начнётвырезкусначалапоследовательности.Еслипропущеновтороечисло,
86 Глава 12. Структуры данных
A Byte of Python (Russian), Версия 2.01
Python закончит вырезку у конца последовательности. Обратите внимание,
что полученная вырезка будет начинаться с указанной начальной позиции,
азаканчиваться прямо перед указанной конечной позицией, т.е. начальная
позициябудетвключенаввырезку,аконечная–нет.
Таким образом, shoplist[1:3] возвращает вырезку из последовательности,
начинающуюся с позиции 1, включает позицию 2, но останавливается на
позиции 3, и поэтому возвращает вырезкуиз двух элементов. Аналогично,
shoplist[:] возвращаеткопиювсейпоследовательности.
Вырезка может осуществляться и с отрицательными значениями. Отрица-
тельныечислаобозначаютпозициюсконцапоследовательности.Например,
shoplist[:-1] вернёт вырезку из последовательности, исключающую по-
следнийэлемент,носодержащуювсеостальные.
Крометого,можнотакжеуказатьтретийаргументдлявырезки,которыйбу-
детобозначать шагвырезки(поумолчаниюшагвырезкиравен1):
>>> shoplist =['яблоки ','манго ','морковь ','бананы ']
>>> shoplist[:: 1]
['яблоки', 'манго', 'морковь', 'бананы']
>>> shoplist[:: 2]
['яблоки', 'морковь']
>>> shoplist[:: 3]
['яблоки', 'бананы']
>>> shoplist[:: -1]
['бананы', 'морковь', 'манго', 'яблоки']
Обратитевниманиенато,чтокогдашагравен2,мыполучаемэлементы,на-
ходящиеся на позициях 0, 2, … Когда шаг равен 3, мы получаем элементы с
позиций0,3,…ит.д.
Попробуйте разные комбинации параметров вырезки, используя интерактивную обо-
лочку интерпретатора Python, т.е. его командную строку, чтобы сразу видеть результат.
Последовательности замечательны тем, что они дают возможность обращаться к корте-
жам,спискамистрокамоднимитемжеспособом!
12.6 Множество
Множества–это неупорядоченные наборыпростыхобъектов.Онинеобходимытогда,ко-
гда присутствие объекта в наборе важнее порядка или того, сколько раз данный объект
тамвстречается.
Используя множества, можно осуществлять проверку принадлежности, определять, яв-
ляется ли данное множество подмножеством другого множества, находить пересечения
множествитакдалее.
12.6. Множество 87
A Byte of Python (Russian), Версия 2.01
>>> bri =set(['Бразилия ','Россия ','Индия '])
>>> 'Индия 'inbri
True
>>> 'США'inbri
False
>>> bric =bri.copy()
>>> bric .add( 'Китай ')
>>> bric .issuperset(bri)
True
>>> bri.remove( 'Россия ')
>>> bri &bric # OR bri.intersection(bric)
{'Бразилия', 'Индия'}
Как это работает:
Этот пример достаточно нагляден, так как использует основы теории мно-
жествизшкольногокурсаматематики.
12.7 Ссылки
Когдамысоздаёмобъектиприсваиваемегопеременной,переменнаятолько ссылается
на объект, а не представляет собой этот объект! То есть имя переменной указывает на
ту часть памяти компьютера, где хранится объект. Это называется привязкой имени к
объекту.
Обычно вам не следует об этом беспокоиться, однако есть некоторый неочевидный эф-
фект,окоторомнужнопомнить:
Пример: (сохранитекак reference.py )
print ('Простое присваивание ')
shoplist =['яблоки ','манго ','морковь ','бананы ']
mylist =shoplist # mylist - лишь ещё одно имя, указывающее на тот же объект!
del shoplist[ 0]# Я сделал первую покупку, поэтому удаляю её из списка
print ('shoplist: ', shoplist)
print ('mylist: ', mylist)
# Обратите внимание, что и shoplist, и mylist выводят один и тот же список
# без пункта "яблоко", подтверждая тем самым, что они указывают на один объект.
print ('Копирование при помощи полной вырезки ')
mylist =shoplist[:] # создаём копию путём полной вырезки
del mylist[ 0]# удаляем первый элемент
print ('shoplist: ', shoplist)
print ('mylist: ', mylist)
# Обратите внимание, что теперь списки разные
88 Глава 12. Структуры данных
A Byte of Python (Russian), Версия 2.01
Вывод:
$ python3 reference.py
Простое присваивание
shoplist: ['манго', 'морковь', 'бананы']
mylist: ['манго', 'морковь', 'бананы']
Копирование при помощи полной вырезки
shoplist: ['манго', 'морковь', 'бананы']
mylist: ['морковь', 'бананы']
Как это работает:
Большаячастьобъяснениясодержитсявкомментариях.
Помните, что если вам нужно сделать копию списка или подобной последо-
вательности, или другого сложного объекта (не такого простого объекта, как
целоечисло),вамследуетвоспользоватьсяоперациейвырезки.Есливыпро-
сто присвоите имя переменной другому имени, оба они будут ссылаться на
одинитотжеобъект,аэтоможетпривестикпроблемам,есливынеосторож-
ны.
12.8 Ещё о строках
Мы уже детально обсуждали строки ранее. Что же ещё можно о них узнать? Что ж, вы
знали, например, что строки также являются объектами и имеют методы, при помощи
которыхможноделатьпрактическивсё:отпроверкичастистрокидоудалениякраевых
пробелов?
Все строки, используемые вами в программах, являются объектами класса str. Некото-
рые полезные методы этого класса продемонстрированы на примере ниже. Чтобы по-
смотретьвесьсписокметодов,выполните help(str) .
Пример: (сохранитекак str_methods.py )
name ='Swaroop '# Это объект строки
ifname .startswith( 'Swa'):
print ('Да, строка начинается на "Swa"')
if'a'inname:
print ('Да, она содержит строку "a"')
ifname .find( 'war')!=-1:
print ('Да, она содержит строку "war"')
delimiter ='_*_'
12.8. Ещё о строках 89
A Byte of Python (Russian), Версия 2.01
mylist =['Бразилия ','Россия ','Индия ','Китай ']
print (delimiter .join(mylist))
Вывод:
$ python3 str_methods.py
Да, строка начинается на "Swa"
Да, она содержит строку "a"
Да, она содержит строку "war"
Бразилия_*_Россия_*_Индия_*_Китай
Как это работает:
Здесьмывидимсразунесколькометодовстроквдействии.Метод startswith служитдля
того,чтобыопределять,начинаетсялистрокаснекоторойзаданнойподстроки.Оператор
inиспользуетсядляпроверки,являетсялинекотораястрокачастьюданнойстроки.
Метод findиспользуетсядляопределенияпозицииданнойподстрокивстроке; findвоз-
вращает -1,если подстрокане обнаружена.В классе strтакжеимеется отличныйметод
дляобъединения( join)3элементовпоследовательности суказаннойстрокойв качестве
разделителя междуэлементами, возвращающий большую строку,сгенерированную та-
кимобразом.
12.9 Резюме
МыдетальнорассмотрелиразличныевстроенныеструктурыданныхPython.Этиструк-
турыданныхбудуткрайневажныдлянаписанияпрограммсущественногоразмера.
Теперь, когда мы накопили достаточно базовых знаний о Python, далее посмотрим, как
проектироватьиписатьнастоящуюпрограммунаPython.
3join– англ.«объединять’»( прим.перев. )
90 Глава 12. Структуры данных
Решение задач
Мы рассмотрели различные части языка Python, и теперь посмотрим, как все эти части
работают вместе, проектируя и составляя программу, которая делаетчто-то полезное.
Цельсостоитвтом,чтобынаучитьсяписатьсценариинаязыкеPythonсамостоятельно.
13.1 Задача
Перед нами стоит следующая задача: Составить программу, которая создаёт резервные
копии всех наших важных файлов .
Хотязадачаипроста,информацииявнонедостаточно,чтобыприступатькеёрешению.
Необходимнекоторыйдополнительный анализ.Например,какмывыберем, какиефай-
лынеобходимокопировать? Какиххранить? Гдеиххранить?
После надлежащего анализа мы проектируем нашу программу. Мы создаём список,
описывающийто,какнашапрограммадолжнаработать.Вданномслучаеясоздалсписок
того,как ясебепредставляюеёработу.Когдавыпроектируетепрограмму,увасможетпо-
лучитьсядругойрезультат,посколькукаждыйчеловекпредставляетсебеэтопо-своему,
такчтоэтовпорядкевещей.
1.Файлыикаталоги,которыенеобходимоскопировать,собираютсявсписок.
2.Резервныекопиидолжныхранитьсявосновномкаталогерезерва.
3.Файлыпомещаютсявzip-архив.
4.Именемдляzip-архиваслужиттекущаядатаивремя.
5.Будемиспользоватьстандартнуюкоманду zip,имеющуюсяпоумолчаниювлюбом
стандартномдистрибутивеGNU/Linux.ПользователиWindowsмогут установить её
состраницыпроектаGnuWin32 идобавить“ C:\Program Files\GnuWin32\bin ”кси-
стемнойпеременнойокруженияPATH,аналогичнотому,какмыэто делалидляса-
мойкоманды“python”.Обратитевнимание,чтодляэтогоподойдётлюбаякоманда
архивации, если у неё есть интерфейс командной строки, чтобы ей можно было
передаватьаргументыизнашегосценария.
91
A Byte of Python (Russian), Версия 2.01
13.2 Решение
Кактолькопроектпрограммыболее-менееустоялся,можноприступатькнаписаниюко-
да,которыйибудетявляться реализацией нашегорешения.
Сохранитекак backup_ver1.py :
import os
import time
# 1. Файлы и каталоги, которые необходимо скопировать, собираются в список.
source =['"C:\\My Documents "','C:\\Code ']
# Заметьте, что для имён, содержащих пробелы, необходимо использовать
# двойные кавычки внутри строки.
# 2. Резервные копии должны храниться в основном каталоге резерва.
target_dir ='E:\\Backup '# Подставьте тот путь, который вы будете использовать.
# 3. Файлы помещаются в zip-архив.
# 4. Именем для zip-архива служит текущая дата и время.
target =target_dir +os.sep +time .strftime( '%Y%m%d%H%M%S')+'.zip '
# 5. Используем команду "zip" для помещения файлов в zip-архив
zip_command ="zip -qr {0} {1} ".format(target, ''.join(source))
# Запускаем создание резервной копии
ifos.system(zip_command) ==0:
print ('Резервная копия успешно создана в ', target)
else :
print ('Создание резервной копии НЕ УДАЛОСЬ ')
Вывод:
$ python3 backup_ver1.py
Резервная копия успешно создана в E:\\Backup\\20080702185040.zip
Теперьнаступаетстадия тестирования ,когдамыпроверяем,правильнолиработаетна-
шапрограмма.Еслионаработаетнетак,какожидалось,нампридётсязанятьсяеё отлад-
кой(дебагом)1,т.е.устранением багов(ошибок)впрограмме.
Еслиприведённая вышепрограммау вас незаработает, допишите print(zip_command)
прямо перед вызовом os.system и запустите программу. После этого скопируйте вы-
веденную команду “zip_command” и вставьте её в командную строку, чтобы проверить,
работает ли она корректно сама по себе. Если она не срабатывает, проверьте справку по
1debug–применительноккомпьютернымпрограммамобозначает отладку(обнаружениеиустранение
ошибок,которыеприэтомпринятоназывать«bug»,т.е.«жук»).Повсейвидимости,это берётсвоёначало
с процедуры изгнания насекомых из схем больших ЭВМ, хотя само понятие «bug» в смысле маленькой
неисправности встречается и в более ранней литературе, например, в записях Томаса Эдисона 1878 года.
(прим. перев. )
92 Глава 13. Решение задач
A Byte of Python (Russian), Версия 2.01
команде “zip”, чтобы выяснить, в чём может быть проблема. Если команда успешно вы-
полняется,проверьте,совпадаетливашапрограмманаPythonвточностиспрограммой,
приведённойвыше.
Как это рабтает:
Вызаметили,какмыпревратилинаш проектвкодшагзашагом.
Мыиспользовалимодули osиtime,предварительноимпортировавих.Далее
мыуказалифайлыикаталогидлярезервногокопированиявсписке source2.
Каталогназначения–этокаталог,вкотороммысохраняемвсерезервныеко-
пии,ионуказываетсявпеременной target_dir .Именемzip-архива,который
мысоздаём,будеттекущаядатаивремя,которыегенерируютсяприпомощи
функции time.strftime() .Унегобудетрасширение .zip,ихранитьсяонбу-
детвкаталоге target_dir .
Обратитевниманиенаупотреблениепеременной os.sep–онасодержитраз-
делитель пути для конкретной операционной системы, т.е. он будет '/'в
GNU/LinuxиUnix3,'\\'вWindowsи ':'вMacOS.Использование os.sepвме-
сто этих символов напрямую делает программу переносимой, и она сможет
работатьнавсехэтихоперационныхсистемах.
Функция time.strftime() принимает в качестве аргумента формат вывода
времени, например, такой, как мы указали в программе выше. Символ фор-
мата %Yбудетзамещёнгодомистолетием.Символ %mбудетзамещёнмесяцем
в форме числа от 01до12, и так далее. Полный список таких символов фор-
матаможнонайтив справочникепоPython .
Имяконечногоzip-файламысоздаёмприпомощиоператора,который соеди-
няетстроки,т.е.объединяетдвестрокиивозвращаетновую.Послеэтогомы
создаёмстроку zip_command ,котораясодержиткоманду,которуюмынамере-
ны выполнить. Проверить, работает ли эта команда, можно запустив её от-
дельно в командной оболочке (терминал в GNU/Linux или командная строка
DOS).
Команда zip,которуюмыиспользуем,имеетнекоторыепараметры.Параметр
“-q” используется для указания, что команда должна сработать тихо4. Пара-
метр “ -r” обозначает, что команда архивации должна работать рекурсивно5
длякаталогов,т.е.должнавключатьвсеподкаталогиифайлы.Обапараметра
объединены и указаны в краткой форме “ -qr”. За параметрами следует имя
создаваемогоzip-архива, за которымуказываетсясписокфайлов икаталогов
длярезервногокопирования.Мыпревращаемсписок sourceвстроку,исполь-
зуяужезнакомыйнамметод join.
2source– англ.«источник»( прим.перев. )
3Под словом «Unix» здесь подразумеваются все операционные системы, построенные по принципам
ОСUnix,анетолькоонасамапосебе.Примерамитакихоперационныхсистемявляютсявседистрибутивы
GNU/Linux,семействоОС*BSD,Android,Solarisит.д.( прим.перев. )
4quietly– англ.«тихо»( прим.перев. )
5recursive– англ.«рекурсивно»( прим.перев. )
13.2. Решение 93
A Byte of Python (Russian), Версия 2.01
Затеммы,наконец, выполняем командуприпомощифункции os.system ,ко-
тораязапускаеткомандутак,какбудтоонабылазапущенаиз системы,т.е.из
команднойоболочки.Онавозвращает 0,есликомандавыполненауспешно,в
противномслучаеонавозвращаеткодошибки.
Взависимостиотвыводакоманды,мыпечатаемсоответствующеесообщение
отом,успешнымбылосозданиерезервныхкопийилинет.
Вотивсё,мысоздалисценарийдлясохранениярезервныхкопийнашихваж-
ныхфайлов!
Замечание для пользователей Windows
Вместо управляющей последовательности для обратной наклонной черты могут
использоваться «сырые»6строки. Например, можно писать “ C:\\Documents ” или
“r'C:\Documents' ”.Однако, неиспользуйте“ 'C:\Documents' ”,таккаквэтомслучаеока-
жется,чтовыпытаетесьприменитьнеизвестнуюуправляющуюпоследовательность \D.
Теперь,когдаунасестьрабочийсценарийрезервногокопирования,мыможемисполь-
зовать его для создания копий наших файлов. Пользователям GNU/Linux и Unix реко-
мендуется сделать этот программный файл исполнимым , чтобы иметь возможность за-
пускать его в любое время из любого места. Это называется операционной фазой или
развёртыванием программы.
Программа,приведённаявыше,работаеткорректно,но(обычно)поначалупрограммыне
работают так, как вы того ожидаете. Проблемы могут возникать вследствие неправиль-
ного проектирования программы, допущения ошибки при наборе программного кода
и т.д. В таких случаях приходится возвращаться к стадии проектирования или отладки
программы.
13.3 Вторая версия
Перваяверсиянашегосценарияработает.Темнеменее,егоможноулучшитьтак,чтобы
было удобнее пользоваться в повседневной работе. Это называется стадией поддержки
программы.
Одно из улучшений, показавшееся мне полезным, – это лучший механизм именова-
нияфайлов:использование временивкачествеименифайла,сохраняющегосявкаталог
стекущейдатойвкачествеимени,которыйвсвоюочередь,расположенвглавномката-
логедляхранениярезервныхкопий.Первоедостоинствоэтогосостоитвтом,чтокопии
хранятся в иерархической структуре, которой легче управлять. Второе достоинство – в
том, что имена файлов намного короче. Третье достоинство состоит в том, что по име-
нам каталогов можно легко определить, в какие дни создавались резервные копии, так
каккаталогсоздаётсятольковслучаерезервногокопированияданныхвэтотдень.
Сохранитекак backup_ver2.py :
6raw– англ.«сырой»,«необработанный»( прим.перев )
94 Глава 13. Решение задач
A Byte of Python (Russian), Версия 2.01
import os
import time
# 1. Файлы и каталоги, которые необходимо скопировать, собираются в список.
source =['"C:\\My Documents "','C:\\Code ']
# Заметьте, что для имён, содержащих пробелы, необходимо использовать
# двойные кавычки внутри строки.
# 2. Резервные копии должны храниться в основном каталоге резерва.
target_dir ='E:\\Backup '# Подставьте тот путь, который вы будете использовать.
# 3. Файлы помещаются в zip-архив.
# 4. Текущая дата служит именем подкаталога в основном каталоге
today =target_dir +os.sep +time .strftime( '%Y%m%d')
# Текущее время служит именем zip-архива
now =time .strftime( '%H%M%S')
# Создаём каталог, если его ещё нет
ifnot os.path .exists(today):
os.mkdir(today) # создание каталога
print ('Каталог успешно создан ', today)
# Имя zip-файла
target =today +os.sep +now +'.zip '
# 5. Используем команду "zip" для помещения файлов в zip-архив
zip_command ="zip -qr {0} {1} ".format(target, ''.join(source))
# Запускаем создание резервной копии
ifos.system(zip_command) ==0:
print ('Резервная копия успешно создана в ', target)
else :
print ('Создание резервной копии НЕ УДАЛОСЬ ')
Вывод:
$ python3 backup_ver2.py
Каталог успешно создан E:\\Backup\\20080702
Резервная копия успешно создана в E:\\Backup\\20080702\\202311.zip
$ python3 backup_ver2.py
Резервная копия успешно создана в E:\\Backup\\20080702\\202325.zip
Как это работает:
Большая часть программы осталась прежней. Разница в том, что теперь мы
проверяем,существуетликаталогсименем,соответствующемтекущейдате,
внутри главного каталога для хранения резервных копий. Для этого мы ис-
13.3. Вторая версия 95
A Byte of Python (Russian), Версия 2.01
пользуем функцию os.path.exists . Если он не существует, мы создаём его
функцией os.mkdir.
13.4 Третья версия
Втораяверсияужеудобнеедляработысбольшимколичествомрезервныхкопий.Сдру-
гойстороны,когдаихмного,становитсятрудноотличить,какаякопиядлячего.Напри-
мер, мы могли внести значительные изменения в какую-то программу или презента-
цию,итеперьхотимуказатьсутьэтихизмененийвимениzip-архива.Этоголегкоможно
достичьдобавлениемпользовательскогокомментариякимениzip-архива.
Примечание: Следующая программа не работает, так что не переживайте,просто про-
следуйтепоней,таккаквнейсодержитсяурок.
Сохранитекак backup_ver3.py
import os
import time
# 1. Файлы и каталоги, которые необходимо скопировать, собираются в список.
source =['"C:\\My Documents "','C:\\Code ']
# Заметьте, что для имён, содержащих пробелы, необходимо использовать
# двойные кавычки внутри строки.
# 2. Резервные копии должны храниться в основном каталоге резерва.
target_dir ='E:\\Backup '# Подставьте тот путь, который вы будете использовать.
# 3. Файлы помещаются в zip-архив.
# 4. Текущая дата служит именем подкаталога в основном каталоге
today =target_dir +os.sep +time .strftime( '%Y%m%d')
# Текущее время служит именем zip-архива
now =time .strftime( '%H%M%S')
# Запрашиваем комментарий пользователя для имени файла
comment =input ('Введите комментарий --> ')
iflen(comment) ==0:# проверяем, введён ли комментарий
target =today +os.sep +now +'.zip '
else :
target =today +os.sep +now +'_'+
comment .replace( '','_')+'.zip '
# Создаём каталог, если его ещё нет
ifnot os.path .exists(today):
os.mkdir(today) # создание каталога
print ('Каталог успешно создан ', today)
96 Глава 13. Решение задач
A Byte of Python (Russian), Версия 2.01
# 5. Используем команду "zip" для помещения файлов в zip-архив
zip_command ="zip -qr {0} {1} ".format(target, ''.join(source))
# Запускаем создание резервной копии
ifos.system(zip_command) ==0:
print ('Резервная копия успешно создана в ', target)
else :
print ('Создание резервной копии НЕ УДАЛОСЬ ')
Вывод:
$ python3 backup_ver3.py
File "backup_ver3.py", line 25
target = today + os.sep + now + '_' +
^
SyntaxError: invalid syntax
Как это (не) работает:
Эта программа не работает! Python сообщает об обнаружении ошибки син-
таксиса,чтоозначает,чтосценарийнеудовлетворяетструктуре,которуюожи-
даетувидетьPython.КогдаPythonвыдаётсообщениеобошибке,онтакжеука-
зываетнамнаместоошибки.Такчтомыначинаем отладкупрограммысэтой
строки.
Привнимательномрассмотрении,мывидим,чтоодналогическаястрокабы-
ла разбита на две физические строки, но мы не указали, что эти две физи-
ческие строки являются частью одной. На деле же Python просто обнаружил
оператор сложения ( +) без соответствующего операнда в той же логической
строке,апоэтомунезнает,какпродолжать.Помните,чтомыможемуказать,
чтологическаястрокапродолжаетсянаследующейфизическойприпомощи
обратнойнаклоннойчертывконцефизическойстроки.Внесёмэтоисправле-
ние в нашу программу. Коррекция программы при обнаружении ошибок и
называется отладкой7.
13.5 Четвёртая версия
Сохранитекак backup_ver4.py
import os
import time
# 1. Файлы и каталоги, которые необходимо скопировать, собираются в список.
source =['"C:\\My Documents "','C:\\Code ']
# Заметьте, что для имён, содержащих пробелы, необходимо использовать
7bugﬁxing–устранение«багов»,исправлениеошибок( прим.перев )
13.5. Четвёртая версия 97
A Byte of Python (Russian), Версия 2.01
# двойные кавычки внутри строки.
# 2. Резервные копии должны храниться в основном каталоге резерва.
target_dir ='E:\\Backup '# Подставьте тот путь, который вы будете использовать.
# 3. Файлы помещаются в zip-архив.
# 4. Текущая дата служит именем подкаталога в основном каталоге
today =target_dir +os.sep +time .strftime( '%Y%m%d')
# Текущее время служит именем zip-архива
now =time .strftime( '%H%M%S')
# Запрашиваем комментарий пользователя для имени файла
comment =input ('Введите комментарий --> ')
iflen(comment) ==0:# проверяем, введён ли комментарий
target =today +os.sep +now +'.zip '
else :
target =today +os.sep +now +'_'+\
comment .replace( '','_')+'.zip '
# Создаём каталог, если его ещё нет
ifnot os.path .exists(today):
os.mkdir(today) # создание каталога
print ('Каталог успешно создан ', today)
# 5. Используем команду "zip" для помещения файлов в zip-архив
zip_command ="zip -qr {0} {1} ".format(target, ''.join(source))
# Запускаем создание резервной копии
ifos.system(zip_command) ==0:
print ('Резервная копия успешно создана в ', target)
else :
print ('Создание резервной копии НЕ УДАЛОСЬ ')
Вывод:
$ python3 backup_ver4.py
Введите комментарий --> added new examples
Резервная копия успешно создана в E:\Backup\20080702\202836_added_new_examples.zip
$ python3 backup_ver4.py
Введите комментарий -->
Резервная копия успешно создана в E:\Backup\20080702\202839.zip
Как это работает:
Теперьэтапрограммаработает!Давайтепросмотримвсеулучшения,сделан-
ные нами для версии 3. Мы запрашиваем пользовательский комментарий
при помощи функции input, а затем проверяем, ввёл ли пользователь что-
98 Глава 13. Решение задач
A Byte of Python (Russian), Версия 2.01
либо, определяя длину введённой строки функцией len. Если пользователь
простонажал ENTER,невводяникакоготекста(можетбыть,этобылорегуляр-
ное создание резервной копии, или никаких особых изменений внесено не
было),мыпродолжаемтакже,какделалидосихпор.
Если же комментарий был введён, он добавляется к имени zip-архива перед
расширением .zip.Обратитевнимание,чтомызаменяемпробелывкоммен-
тарииподчёркиваниями:управлятьфайламибезпробеловвименахнамного
легче.
13.6 Дополнительные усовершенствования
Четвёртая версия – вполне удовлетворительный рабочий сценарий для большинства
пользователей,однаконетпределовсовершенства.Например,впрограммуможнодоба-
витьуровень подробности8вывода,чтобыприуказаниипараметра“ -v”онастановилась
более«разговорчивой».
Ещё одним возможным улучшением была бы возможность передавать сценарию дру-
гиефайлыикаталогипрямовкоманднойстроке.Этиименаможнополучатьизсписка
sys.argv идобавлятькнашемусписку sourceприпомощиметода extendкласса list.
Наиболее важным усовершенствованием было бы прекращение использования
os.system для создания архивов, а применение вместо него встроенных модулей
zipfileили tarfile.Ониявляютсячастьюстандартнойбиблиотеки,поэтомувсегдадо-
ступныдляиспользованиябеззависимостиотвнешнейпрограммыzipнакомпьютере.
Вприведённыхпримерахмыиспользовалиспособс os.system длясозданиярезервных
копийисключительновпедагогическихцелях,чтобыпримербылдостаточнопростдля
пониманиялюбымчитателем,нодостаточнореалендлятого,чтобыделатьчто-тополез-
ное.
Попробуйте написать пятую версию с использованием модуля zipﬁleвместо вызова
os.system .
13.7 Процесс разработки программного обеспече-
ния
Впроцессесозданияпрограммымыпрошличерезнесколько стадий.Этистадииможно
свестипримерновтакойсписок:
•Что(Анализ)
•Как(Проектирование)
8verbosity– англ.«многословность».Применительноккомпьютернымпрограммамобозначаетстепень
подробности выводимых программой сообщений, т.е. степень «разговорчивости» программы. Отсюда и
названиеэтогопараметра( прим.перев )
13.6. Дополнительные усовершенствования 99
A Byte of Python (Russian), Версия 2.01
•Создание(Реализация)
•Тестирование(ТестированиеиОтладка)
•Использование(РазвёртываниеиОперирование)
•Поддержка(Усовершенствование)
Процедура, которую мы прошли при написании сценария создания резервных копий
рекомендуется и для других программ: Проведите анализ и проектирование. Начните
реализациюспростейшейверсии.Протестируйтеиотладьтееё.Попользуйтесьею,что-
бы убедиться, что она работает, как ожидалось. После этого добавляйте любые необхо-
димыефункции,повторяяцикл«Создание !Тестирование !Использование»столько
раз,сколькопотребуется.Помните, Программы выращиваются, а не строятся .
13.8 Резюме
Мы увидели, как создавать свои собственные программы/сценарии на Python, а также
различные стадии написания программ. На данном этапе вам будет полезно создать
собственнуюпрограммупотакомурецепту,какмыэтоделаливнастоящейглаве,чтобы
лучшепривыкнутькPython,равнокакикрешениюзадач.
Далеемыобсудимобъектно-ориентированноепрограммирование.
100 Глава 13. Решение задач
Объектно-ориентированное
программирование
Досихпорнашипрограммысостоялиизфункций,т.е.блоковвыражений,которыема-
нипулируют данными. Это называется процедурно-ориентированным стилем програм-
мирования. Существует и другой способ организации программ: объединять данные
ифункционалвнутринекоегообъекта.Этоназывается объектно-ориентированной пара-
дигмойпрограммирования.Вбольшинствеслучаевможноограничитьсяпроцедурным
программированием,апринаписаниибольшойпрограммыилиеслирешениеконкрет-
нойзадачитоготребует,можнопереходитьктехникамобъектно-ориентированногопро-
граммирования.
Дваосновныхаспектаобъектно-ориентированногопрограммирования–классыиобъек-
ты.Класссоздаётновый тип,аобъектыявляются экземплярами класса.Аналогично,ко-
гдамыговоримо«переменныхтипа int»,этоозначает,чтопеременные,которыехранят
целочисленныезначения,являютсяэкземплярами(объектами)класса int.
Замечание для программистов на статических языках
Обратите внимание, что даже целые числа рассматриваются как объекты (класса int),
в отличие от C++ и Java (до версии 1.5), где целые числа являются примитивами. См.
help(int) для более детального описания этого класса. Программисты на C# и Java 1.5
могутзаметитьсходствосконцепцией упаковки и распаковки1.
Объекты могут хранить данные в обычных переменных, которые принадлежат объек-
ту.Переменные,принадлежащиеобъектуиликлассу,называют полями.Объектымогут
также обладать функционалом, т.е. иметь функции, принадлежащие классу. Такиефунк-
циипринятоназывать методами класса.Этатерминологияважна,таккаконапомогает
намотличатьнезависимыефункцииипеременныеоттех,чтопринадлежатклассуили
объекту.Всёвместе(поляиметоды)принятоназывать атрибутами класса.
Полябываютдвухтипов:онимогутпринадлежатькаждомуотдельномуэкземпляруобъ-
екта класса или всему классу. Они называются переменными экземпляра иперемен-
ными класса соответственно.
Класс создаётся ключевым словом class. Поля и методы класса записываются в блоке
1boxingandunboxing
101
A Byte of Python (Russian), Версия 2.01
кодасотступом.
14.1 self
Методыклассаимеютодноотличиеотобычныхфункций:онидолжныиметьдополни-
тельноимя,добавляемоекначалуспискапараметров.Однако,привызовеметоданика-
когозначенияэтомупараметруприсваивать ненужно–егоукажетPython.Этаперемен-
наяуказываетна самобъектэкземпляракласса,ипотрадициионаназывается self2.
Хотяэтомупараметруможнодатьлюбоеимя, настоятельно рекомендуется использовать
толькоимя self;использованиелюбогодругогоименинеприветствуется.Естьмногодо-
стоинствиспользованиястандартногоимени:во-первых,любойчеловек,просматриваю-
щийвашупрограмму,легкоузнаетего;во-вторых,некоторыеспециализированныеИн-
тегрированныесредыразработки(IDE)изначальнорассчитанынаиспользование self.
Замечание для программистов на C++, Java и C#
selfвPythonэквивалентноуказателю thisвC++иссылке thisвJavaиC#.
Вы, должно быть, удивляетесь, как Python присваивает значение selfи почему вам не
нужноуказыватьэтозначениесамостоятельно.Пояснимэтонапримере.Предположим,
унасестькласссименем MyClassиэкземплярэтогоклассасименем myobject.Привызо-
веметодаэтогообъекта,например,“ myobject.method(arg1, arg2) ”,Pythonавтоматиче-
скипревращаетэтов“ MyClass.method(myobject, arg1, arg2) ”–вэтомисостоитсмысл
self.
Этотакжеозначает,чтоесликакой-либометоднепринимаетаргументов,унеговсёрав-
нобудетодинаргумент– self.
14.2 Классы
Простейшийкласспоказанвследующемпримере(сохранитекак simplestclass.py ).
class Person :
pass # Пустой блок
p=Person()
print (p)
Вывод:
$ python3 simplestclass.py
<__main__.Person object at 0x019F85F0>
Как это работает:
2self– англ.«сам»( прим.перев. )
102 Глава 14. Объектно-ориентированное программирование
A Byte of Python (Russian), Версия 2.01
Мы создаём новый класс при помощи оператора classи имени класса. За
этим следует блок выражений, формирующих тело класса. В данном случае
блокунаспуст,начтоуказываетоператора pass.
Далеемысоздаёмобъект-экземпляркласса,записываяимяклассасоскобка-
ми.(Мыузнаембольшео реализации вследующемразделе).Дляпроверкимы
выясняем тип переменной, просто выводя её на экран. Так мы видим, что у
насестьэкземпляркласса Personвмодуле __main__.
Обратите внимание, что выводится также и адрес в памяти компьютера, где
хранится ваш объект. На вашем компьютере адрес будет другим, так как
Pythonхранитобъектытам,гдеимеетсясвободноеместо.
14.3 Методы объектов
Итак, мы выяснили что классы/объекты могут иметь методы, представляющие собой
функции,заисключениемдополнительнойпеременной self.Атеперьдавайтерассмот-
римпример(сохранитекак method.py ).
class Person :
def sayHi (self ):
print ('Привет! Как дела? ')
p=Person()
p.sayHi()
# Этот короткий пример можно также записать как Person().sayHi()
Вывод:
$ python3 method.py
Привет! Как дела?
Как это работает:
Здесь мы видим selfв действии. Обратите внимание, что метод sayHiне
принимаетпараметров,нотемнеменее,имеет selfвопределениифункции.
14.4 Метод __init__
Существует много методов, играющих специальную роль в классах Python. Сейчас мы
увидимзначительностьметода __init__.
Метод __init__ запускается, как только объект класса реализуется. Этот метод полезен
дляосуществленияразногорода инициализации ,необходимойдляданногообъекта.Об-
ратитевниманиенадвойныеподчёркиваниявначалеивконцеимени.
Пример: (сохранитекак class_init.py )
14.3. Методы объектов 103
A Byte of Python (Russian), Версия 2.01
class Person :
def __init__ (self , name):
self .name =name
def sayHi (self ):
print ('Привет! Меня зовут ',self .name)
p=Person( 'Swaroop ')
p.sayHi()
# Этот короткий пример можно также записать как Person('Swaroop').sayHi()
Вывод:
$ python3 class_init.py
Привет! Меня зовут Swaroop
Как это работает:
Здесьмыопределяемметод __init__ так,чтобыонпринималпараметр name
(наряду с обычным self). Далее мы создаём новое поле с именем name. Об-
ратите внимание, что это две разные переменные, даже несмотря на то, что
ониобеназваны name.Этонепроблема,таккакточкаввыражении self.name
обозначает,чтосуществуетнечтосименем«name»,являющеесячастьюобъ-
екта«self»,идругое name–локальнаяпеременная.Посколькумывявномвиде
указываем,ккоторомуименимыобращаемся,путаницыневозникнет.
Важноотметить,чтоприсозданииновогоэкземпляраклассамыневызываем
метод __init__ явнымобразом,апередаёмаргументывскобкахпослеимени
этогокласса.Вэтомизаключаетсяспециальнаярольданногометода.
Послеэтогомыполучаемвозможностьиспользоватьполе self.name внаших
методах,чтоипродемонстрировановметоде sayHi.
14.5 Переменные класса и объекта
Функциональную часть классов и объектов (т.е. методы) мы обсудили, теперь давайте
ознакомимсясчастьюданных.Данные,т.е.поля,являютсянечеминым,какобычными
переменными, заключёнными впространствах имён классов и объектов. Это означает,
что их имена действительны только в контексте этих классов или объектов. Отсюда и
название« пространство имён ».
Существует два типа полей: переменные класса и переменные объекта, которые разли-
чаютсявзависимостиоттого, принадлежит липеременнаяклассуилиобъектусоответ-
ственно.
Переменные класса разделяемы–доступкниммогутполучатьвсеэкземплярыэтогоклас-
са. Переменная класса существует только одна, поэтому когда любой из объектов изме-
няетпеременнуюкласса,этоизменениеотразитсяивовсехостальныхэкземплярахтого
104 Глава 14. Объектно-ориентированное программирование
A Byte of Python (Russian), Версия 2.01
жекласса.
Переменные объекта принадлежаткаждомуотдельномуэкземплярукласса.Вэтомслучае
укаждогообъектаестьсвоясобственнаякопияполя,т.е.неразделяемаяиникоимобра-
зомнесвязаннаясдругимитакимижеполямивдругихэкземплярах.Этолегкопонять
напримере(сохранитекак objvar.py ):
class Robot :
'''Представляет робота с именем.'''
# Переменная класса, содержащая количество роботов
population =0
def __init__ (self , name):
'''Инициализация данных.'''
self .name =name
print ('(Инициализация {0}) '.format( self .name))
# При создании этой личности, робот добавляется
# к переменной 'population'
Robot .population +=1
def __del__ (self ):
'''Я умираю.'''
print ('{0} уничтожается! '.format( self .name))
Robot .population -=1
ifRobot .population ==0:
print ('{0} был последним. '.format( self .name))
else :
print ('Осталось {0:d} работающих роботов. '.format(Robot .population))
def sayHi (self ):
'''Приветствие робота.
Да, они это могут.'''
print ('Приветствую! Мои хозяева называют меня {0}. '.format( self .name))
def howMany ():
'''Выводит численность роботов.'''
print ('У нас {0:d} роботов. '.format(Robot .population))
howMany =staticmethod (howMany)
droid1 =Robot( 'R2-D2 ')
droid1 .sayHi()
Robot .howMany()
14.5. Переменные класса и объекта 105
A Byte of Python (Russian), Версия 2.01
droid2 =Robot( 'C-3PO ')
droid2 .sayHi()
Robot .howMany()
print ("\nЗдесь роботы могут проделать какую-то работу. \n")
print ("Роботы закончили свою работу. Давайте уничтожим их. ")
del droid1
del droid2
Robot .howMany()
Вывод:
$ python3 objvar.py
(Инициализация R2-D2)
Приветствую! Мои хозяева называют меня R2-D2.
У нас 1 роботов.
(Инициализация C-3PO)
Приветствую! Мои хозяева называют меня C-3PO.
У нас 2 роботов.
Здесь роботы могут проделать какую-то работу.
Роботы закончили свою работу. Давайте уничтожим их.
R2-D2 уничтожается!
Осталось 1 работающих роботов.
C-3PO уничтожается!
C-3PO был последним.
У нас 0 роботов.
Как это работает:
Этодлинныйпример,ноонпомогаетпродемонстрироватьприродуперемен-
ных класса и объекта. Здесь population принадлежит классу Robot, и поэто-
му является переменной класса. Переменная nameпринадлежит объекту (ей
присваивается значение при помощи self), и поэтому является переменной
объекта.
Таким образом, мы обращаемся к переменной класса population как
Robot.population , а не self.population . К переменной же объекта name
во всех методах этого объекта мы обращаемся при помощи обозначения
self.name . Помните об этой простой разнице между переменными класса и
объекта. Также имейте в виду, что переменная объекта с тем же именем, что
ипеременнаякласса,сделаетнедоступной(«спрячет»)переменнуюкласса!
Метод howManyпринадлежит классу, а не объекту. Это означает, что мы мо-
жемопределитьегокак classmethod или staticmethod ,взависимостиоттого,
нужнолинамзнать,вкакомклассемынаходимся.Посколькунамненужна
106 Глава 14. Объектно-ориентированное программирование
A Byte of Python (Russian), Версия 2.01
такаяинформация,мывоспользуемся staticmethod .
Мымоглидостичьтогожесамого,используя декораторы :
@staticmethod
def howMany ():
'''Выводит численность роботов.'''
print ('У нас {0:d} роботов. '.format(Robot .population))
Декораторыможносчитатьнекимупрощённымспособомвызоваявногооператора,как
мывиделивэтомпримере.
Пронаблюдайте,какметод __init__ используетсядляинициализацииэкземпляра Robot
с именем. В этом методе мы увеличиваем счётчик population на 1, так как добавляем
ещё одного робота. Также заметьте, что значения self.name для каждого объекта свои,
чтоуказываетнаприродупеременныхобъекта.
Помните, что к переменным и методам самого объекта нужно обращаться, пользуясь
только self.Этоназывается доступом к атрибутам .
Вэтомпримеремытакженаблюдалиприменение строк документации дляклассов,рав-
нокакидляметодов.Вовремявыполнениямыможемобращатьсякстрокедокумента-
цииклассаприпомощи“ Robot.__doc__ ”,акстрокедокументацииметода–припомощи
“Robot.sayHi.__doc__ ”.
Нарядусметодом __init__,существуетидругойспециальныйметод __del__,который
вызываетсятогда,когдаобъектсобираетсяумереть,т.е.когдаонбольшенеиспользуется,
изанимаемаяимпамятьвозвращаетсяоперационнойсистемедлядругогоиспользова-
ния.Вэтомметодемыпростоуменьшаемсчётчик Robot.population на1.
Метод __del__запускаетсялишьтогда,когдаобъектперестаётиспользоваться,апоэтому
заранее неизвестно, когдаименно этот момент наступит. Чтобы увидеть его в действии
явно,придётсявоспользоватьсяоператором del,чтомыисделаливыше.
Примечание для программистов на C++/Java/C#
ВPythonвсечленыкласса(включаяданные)являются публичными (public),авсеметоды
–виртуальными (virtual).
Исключение:Еслиимяпеременнойначинаетсяс двойного подчёркивания ,как,например,
__privatevar ,Pythonделаетэтупеременнуюприватной(private).Поэтомупринятоимя
любой переменной, которая должна использоваться только внутри класса или объекта,
начинатьсподчёркивания;всежеостальныеименаявляютсяпубличными,имогутис-
пользоватьсявдругихклассах/объектах.Помните,чтоэтолишьтрадиция,иPythonвовсе
необязываетделатьименнотак(кромедвойногоподчёркивания).
14.5. Переменные класса и объекта 107
A Byte of Python (Russian), Версия 2.01
14.6 Наследование
Одно из главных достоинств объектно-ориентированного программирования заключа-
ется в многократном использовании одного и того же кода, и один из способов этого
достичь – при помощи механизма наследования . Легче всего представить себе наследо-
ваниеввидеотношениямеждуклассамикак тип и подтип .
Представим, что нам нужно написать программу, которая отслеживает информацию о
преподавателях и студентах в колледже. У них есть некоторые общие характеристики:
имя, возраст и адрес. Есть также и специфические характеристики, такие как зарплата,
курсыиотпускдляпреподавателей,атакжеоценкииоплатазаобучениедлястудентов.
Можно создать для них независимые классы и работать с ними, но тогда добавление
какой-либо новой общей характеристики потребует добавления её к каждому из этих
независимыхклассоввотдельности,чтоделаетпрограммунеповоротливой.
Лучше создать общий класс с именем SchoolMember , а затем сделать так, чтобы классы
преподавателя и студента наследовали этот класс, т.е. чтобы они стали подтипами этого
типа(класса),послечегодобавитьлюбыеспецифическиехарактеристикикэтимподти-
пам.
У такого подхода есть множество достоинств. Если мы добавим/изменим какую-либо
функциональность в SchoolMember , это автоматически отобразится и во всех подтипах.
Например,мыможемдобавитьновоеполеудостоверениядляпреподавателейистуден-
тов,простодобавивегокклассу SchoolMember .Сдругойстороны,изменениявподтипах
никакневлияютнадругиеподтипы.Ещёоднодостоинствосостоитвтом,чтообращать-
ся к объекту преподавателя или студента можно как к объекту SchoolMember , что может
быть полезно в ряде случаев, например, для подсчёта количества человек в школе. Ко-
гдаподтипможетбытьподставленвлюбомместе,гдеожидаетсяродительскийтип,т.е.
объектсчитаетсяэкземпляромродительскогокласса,этоназывается полиморфизмом .
Заметьте также, что код родительского класса используется многократно , и нет необхо-
димостикопироватьегововсехклассы,какпришлосьбывслучаеиспользованиянеза-
висимыхклассов.
Класс SchoolMember вэтойситуацииназывают базовым классом или надклассом3.Классы
TeacherиStudentназывают производными классами или подклассами4.
Рассмотримтеперьэтотпримерввидепрограммы(сохранитекак inherit.py ).
class SchoolMember :
'''Представляет любого человека в школе.'''
def __init__ (self , name, age):
self .name =name
self .age =age
print ('(Создан SchoolMember: {0}) '.format( self .name))
def tell (self ):
3также«суперкласс»,‘«родительскийкласс»( прим.перев. )
4также«субкласс»,«класс-наследник»( прим.перев. )
108 Глава 14. Объектно-ориентированное программирование
A Byte of Python (Russian), Версия 2.01
'''Вывести информацию.'''
print ('Имя: "{0}"Возраст: "{1}"'.format( self .name, self .age), end ="")
class Teacher (SchoolMember):
'''Представляет преподавателя.'''
def __init__ (self , name, age, salary):
SchoolMember .__init__( self , name, age)
self .salary =salary
print ('(Создан Teacher: {0}) '.format( self .name))
def tell (self ):
SchoolMember .tell( self )
print ('Зарплата: "{0:d} "'.format( self .salary))
class Student (SchoolMember):
'''Представляет студента.'''
def __init__ (self , name, age, marks):
SchoolMember .__init__( self , name, age)
self .marks =marks
print ('(Создан Student: {0}) '.format( self .name))
def tell (self ):
SchoolMember .tell( self )
print ('Оценки: "{0:d} "'.format( self .marks))
t=Teacher( 'Mrs. Shrividya ',40,30000 )
s=Student( 'Swaroop ',25,75)
print ()# печатает пустую строку
members =[t, s]
for member inmembers:
member .tell() # работает как для преподавателя, так и для студента
Вывод:
$ python3 inherit.py
(Создан SchoolMember: Mrs. Shrividya)
(Создан Teacher: Mrs. Shrividya)
(Создан SchoolMember: Swaroop)
(Создан Student: Swaroop)
Имя:"Mrs. Shrividya" Возраст:"40" Зарплата: "30000"
Имя:"Swaroop" Возраст:"25" Оценки: "75"
Как это работает:
Чтобы воспользоваться наследованием, при определении класса мы указы-
14.6. Наследование 109
A Byte of Python (Russian), Версия 2.01
ваем имена его базовых классов в виде кортежа, следующего за сразу за его
именем.Далеемывидим,чтометод __init__ базовогоклассавызываетсяяв-
но при помощи переменной self, чтобы инициализировать часть объекта,
относящуюсякбазовомуклассу.Этооченьважнозапомнить:Pythonневызы-
вает конструктор базового класса автоматически – его необходимо вызывать
самостоятельновявномвиде.
Здесьжемывидим,какможновызыватьметодыбазовогокласса,предваряя
записьимениметодаименемкласса,азатемпередаваяпеременную selfвме-
стесдругимиаргументами.
Обратите внимание, что при вызове метода tellиз класса SchoolMember
экземпляры Teacher или Student можно использовать как экземпляры
SchoolMember .
Заметьте также, что вызывается метод tellиз подкласса, а не метод tellиз
класса SchoolMember .Этоможнопонятьследующимобразом:Python всегдана-
чинаетпоискметодоввсамомклассе,чтоониделаетвданномслучае.Если
же он не находит метода, он начинает искать методы, принадлежащие базо-
вымклассампоочереди,впорядке,вкоторомониперечисленывкортежепри
определениикласса.
Замечаниепотерминологии:еслипринаследованииперечисленоболееод-
ногокласса,этоназывается множественным наследованием .
Параметр endиспользуется в методе tell()для того, чтобы новая строка на-
чиналасьчерезпробелпослевызова print().
14.7 Метаклассы5
Вобширнойтемеобъектно-ориентированногопрограммированиясуществуетещёмно-
говсего,номылишьслегкакоснёмсянекоторыхконцепций,чтобывыпростозналиоб
ихсуществовании.
Точнотакже,какклассыиспользуютсядлясозданияобъектов,можноиспользоватьме-
таклассыдлясозданияклассов.Метаклассысуществуютдляизмененияилидобавления
новогоповедениявклассы.
Давайтерассмотримпример.Допустим,мыхотимбытьуверены,чтомывсегдасоздаём
исключительно экземпляры подклассов класса SchoolMember , и не создаём экземпляры
самогокласса SchoolMember .
Для достижения этой цели мы можем использовать концепцию под названием «аб-
страктныебазовыеклассы».Этоозначает,чтотакойкласс абстрактен ,т.е.являетсялишь
некойконцепцией,непредназначеннойдляиспользованиявкачествереальногокласса.
5воригинальнойверсиикнигиэтотпараграфневидимдлячитателей,таккакнаходитсявкоммента-
рииспометкойавтора“Itistoosuddentointroducethisconcepthere.”,чтоозначает«Слишкомнеожиданно
представлениеэтойконцепцииздесь.»’( прим.перев. )
110 Глава 14. Объектно-ориентированное программирование
A Byte of Python (Russian), Версия 2.01
Мыможемобъявитьнашкласскакабстрактныйбазовыйклассприпомощивстроенного
метаклассапоимени ABCMeta.
#!/usr/bin/env python
# Filename: inherit_abc.py
from abc import *
class SchoolMember (metaclass =ABCMeta):
'''Представляет любого человека в школе.'''
def __init__ (self , name, age):
self .name =name
self .age =age
print ('(Создан SchoolMember: {0}) '.format( self .name))
@abstractmethod
def tell (self ):
'''Вывести информацию.'''
print ('Имя: "{0}"Возраст: "{1}"'.format( self .name, self .age), end ="")
class Teacher (SchoolMember):
'''Представляет преподавателя.'''
def __init__ (self , name, age, salary):
SchoolMember .__init__( self , name, age)
self .salary =salary
print ('(Создан Teacher: {0}) '.format( self .name))
def tell (self ):
SchoolMember .tell( self )
print ('Зарплата: "{0:d} "'.format( self .salary))
class Student (SchoolMember):
'''Представляет студента.'''
def __init__ (self , name, age, marks):
SchoolMember .__init__( self , name, age)
self .marks =marks
print ('(Создан Student: {0}) '.format( self .name))
def tell (self ):
SchoolMember .tell( self )
print ('Оценки: "{0:d} "'.format( self .marks))
t=Teacher( 'Mrs. Shrividya ',40,30000 )
s=Student( 'Swaroop ',25,75)
#m = SchoolMember('abc', 10)
# Это приведёт к ошибке: "TypeError: Can't instantiate abstract class
# SchoolMember with abstract methods tell"
14.7. Метаклассы 111
A Byte of Python (Russian), Версия 2.01
print ()# печатает пустую строку
members =[t, s]
for member inmembers:
member .tell() # работает как для преподавателя, так и для студента
Вывод:
$ python3 inherit.py
(Создан SchoolMember: Mrs. Shrividya)
(Создан Teacher: Mrs. Shrividya)
(Создан SchoolMember: Swaroop)
(Создан Student: Swaroop)
Имя:"Mrs. Shrividya" Возраст:"40" Зарплата: "30000"
Имя:"Swaroop" Возраст:"25" Оценки: "75"
Как это работает:
Мыможемобъявитьметод tellкласса SchoolMember абстрактным,итакимобразомав-
томатическизапретимсоздаватьэкземплярыкласса SchoolMember .
Темнеменее,мыможемработатьсэкземплярами TeacherиStudentтак,какбудтоони
экземпляры SchoolMember ,посколькуониявляютсяподклассами.
14.8 Резюме
Мы изучили различные аспекты классов и объектов, равно как и терминологию,
связанную с ними. Мы также увидели ряд достоинств и «подводных камней»
объектно-ориентированного программирования. Python – в высокой степени объектно-
ориентирован,поэтомупониманиеэтихпринциповоченьпоможетвамвдальнейшем.
Далеемыузнаем,какработатьсвводом/выводомиполучатьдоступкфайламвPython.
112 Глава 14. Объектно-ориентированное программирование
Ввод-вывод
Рано или поздно возникают ситуации, когда программа должна взаимодействовать с
пользователем.Например,принятькакие-нибудьданныеотпользователя,азатемвыве-
стирезультаты.Дляэтогоприменяютсяфункции input()иprint()соответственно.
Длявыводаможнотакжеиспользоватьразличныеметодыкласса str(строка).Кпримеру,
при помощи метода rjustможно получить строку, выравненную по правому краю к
указаннойширине.См. help(str) дляболееподробногоописания.
Ещёоднимраспространённымтипомввода/выводаявляетсяработасфайлами.Возмож-
ностьсоздавать,читатьизаписыватьвфайлыявляетсяключевойдлямногихпрограмм,
поэтомувнастоящейглавеимырассмотримэтотаспект.
15.1 Ввод от пользователя
Сохранитеэтупрограммукак user_input.py :
def reverse (text):
return text[:: -1]
def is_palindrome (text):
return text ==reverse(text)
something =input ('Введите текст: ')
if(is_palindrome(something)):
print ("Да, это палиндром ")
else :
print ("Нет, это не палиндром ")
Вывод:
$ python3 user_input.py
Введите текст: сэр
Нет, это не палиндром
$ python3 user_input.py
Введите текст: мадам
Да, это палиндром
113
A Byte of Python (Russian), Версия 2.01
$ python3 user_input.py
Введите текст: топот
Да, это палиндром
Как это работает:
Мы применяем операцию вырезки для переворачивания текста. Мы уже
видели, как создаются вырезки из последовательностей при помощи кода
“seq[a:b]”,начинаяспозиции aдопозиции b.Новедьмытакжеможемука-
затьитретийаргумент,определяющий шаг,скоторымпроизводитсявырез-
ка. По умолчанию шаг равен 1, поэтому и возвращается непрерывный фраг-
мент текста. Указание отрицательного шага, т.е. -1приведёт к выводу текста
вобратномпорядке.
Функция input()принимает строку в качестве аргумента и показывает её
пользователю. Затем она ждёт, чтобы пользователь набрал что-нибудь и на-
жалклавишуввода.Кактолькопользовательэтосделал,функция input()воз-
вращаетвведённыйпользователемтекст.
Мы считываем этот текст и выстраиваем его в обратном порядке. Если пе-
ревёрнутый и исходный текст одинаковы, значит введённый текст является
палиндромом .
Домашнее задание
Проверка, является ли текст палиндромом должна также игнорировать знаки пунктуа-
ции, пробелы и регистр букв. Например, «А роза упала на лапу Азора» также является
палиндромом, но наша текущая программа так не считает. Попробуйте улучить её так,
чтобыонараспозналаэтотпалиндром.
Подсказка: (не читайте)
Воспользуйтеськортежем(список всехзнаковпунктуацииможнонайти здесь),содержа-
щим все запрещённые символы, и примените тест на принадлежность, чтобы обнару-
житьсимволы,подлежащиеудалению,т.е.forbidden=(‘!’,‘?’,‘.’,…).
15.2 Файлы
Открыватьииспользоватьфайлыдлячтенияилизаписиможнопутёмсозданияобъекта
класса file,ачитать/записыватьвфайл–припомощиегометодов read,readline или
writeсоответственно. Возможность читать или записывать в файл зависит от режима,
указанногоприоткрытиифайла.Поокончанииработысфайлом,нужновызватьметод
close1,чтобыуказатьPython,чтофайлбольшенеиспользуется.
1close– англ.«закрывать»( прим.перев )
114 Глава 15. Ввод-вывод
A Byte of Python (Russian), Версия 2.01
Пример: (сохранитекак using_file.py )
poem ='''\
Программировать весело.
Если работа скучна,
Чтобы придать ей весёлый тон -
используй Python!
'''
f=open ('poem.txt ','w')# открываем для записи (writing)
f.write(poem) # записываем текст в файл
f.close() # закрываем файл
f=open ('poem.txt ')# если не указан режим, по умолчанию подразумевается
# режим чтения ('r'eading)
while True :
line =f.readline()
iflen(line) ==0:# Нулевая длина обозначает конец файла (EOF)
break
print (line, end ='')
f.close() # закрываем файл
Вывод:
$ python3 using_file.py
Программировать весело.
Если работа скучна,
Чтобы придать ей весёлый тон -
используй Python!
Как это работает:
Сперва мы открываем файл при помощи встроенной функции openс указа-
ниемименифайлаирежима,вкотороммыхотимегооткрыть.Режимможет
бытьдлячтения( 'r'),записи( 'w')илидобавления( 'a')2.Можнотакжеука-
зать, в каком виде мы будем считывать, записывать или добавлять данные:
в текстовом ( 't') или бинарном ( 'b'). На самом деле существует много дру-
гих режимов, и help(open) даст вам их детальное описание. По умолчанию
open()открываетфайлкактекстврежимедлячтения.
Внашемпримеремысначалаоткрываемфайлврежимезаписитекстаиис-
пользуем метод writeфайлового объекта для записи в файл, после чего за-
крываемфайлприпомощи close.
Далеемыоткрываемтотжесамыйфайлдлячтения.Вэтомслучаенетнужды
указыватьрежим,таккакрежим«чтениятекстовогофайла»применяетсяпо
умолчанию.Мысчитываемфайлпострочнометодом readline вцикле.Этот
2read, writeи appendсоответственно( прим.перев. )
15.2. Файлы 115
A Byte of Python (Russian), Версия 2.01
метод возвращает полную строку, включая символ перевода строки в конце.
Когдажеонвозвращаетпустуюстроку,этоозначает,чтомыдостигликонца
файла,имыпрерываемциклприпомощи break.
Поумолчаниюфункция print()выводиттекст,автоматическидобавляясим-
вол перевода строки в конце. Мы подавляем этот символ, указывая end='',
поскольку строки, считанные из файла, и без того оканчиваются символом
переводастроки.И,наконец,мызакрываемфайлспомощью close.
Теперьпроверяемсодержимоефайла poem.txt,чтобыубедиться,чтопрограм-
мадействительнозаписалатекствнегоисчиталаизнего.
15.3 Pickle
Pythonпредоставляетстандартныймодульсименем pickle3,припомощикоторогомож-
носохранять любойобъектPythonвфайле,азатемизвлекатьегообратно.Этоназывается
длительным хранениемобъекта.
Пример: (сохранитекак pickling.py ):
import pickle
# имя файла, в котором мы сохраним объект
shoplistfile ='shoplist.data '
# список покупок
shoplist =['яблоки ','манго ','морковь ']
# Запись в файл
f=open (shoplistfile, 'wb')
pickle .dump(shoplist, f) # помещаем объект в файл
f.close()
del shoplist # уничтожаем переменную shoplist
# Считываем из хранилища
f=open (shoplistfile, 'rb')
storedlist =pickle .load(f) # загружаем объект из файла
print (storedlist)
Вывод:
$ python3 pickling.py
['яблоки', 'манго', 'морковь']
Как это работает:
3pickle– англ.«мариновать»,«солить»( прим.перев. )
116 Глава 15. Ввод-вывод
A Byte of Python (Russian), Версия 2.01
Чтобысохранитьобъектвфайле,намнужносперваоткрытьфайлспомощью
openврежимебинарнойзаписи( 'wb'),послечеговызватьфункцию dumpиз
модуля pickle.Этотпроцессназывается«консервацией»(«pickling»).
После этого мы извлекаем объект при помощи функции loadиз модуля
pickle,котораявозвращаетобъект.Этотпроцессназывается«расконсерваци-
ей»(«unpickling»).
15.4 Резюме
Мы обсудили разные типы ввода/вывода, а также работу с файлами и использование
модуля pickle.
Далеемыпознакомимсясконцепциейисключений.
15.4. Резюме 117
A Byte of Python (Russian), Версия 2.01
118 Глава 15. Ввод-вывод
Исключения
Исключения возникают тогда, когда в программе возникает некоторая исключительная
ситуация. Например, к чему приведёт попытка чтения несуществующего файла? Или
еслифайлбылслучайноудалён,покапрограммаработала?Такиеситуацииобрабатыва-
ютсяприпомощи исключений .
Этокасаетсяипрограмм,содержащихнедействительныекоманды.ВэтомслучаеPython
поднимает рукиисообщает,чтообнаружил ошибку.
16.1 Ошибки
Рассмотримпростойвызовфункции print.Что,еслимыошибочнонапишем printкак
Print?Обратитевниманиеназаглавнуюбукву.ВэтомслучаеPython поднимает синтак-
сическуюошибку.
>>> Print( 'Привет, Мир! ')
Traceback (most recent call last):
File "<pyshell#0>" , line 1, in <module>
Print( 'Привет, Мир! ')
NameError : name 'Print' is not defined
>>> print ('Привет, Мир! ')
Привет, Мир!
Обратитевнимание,чтобылаподнятаошибка NameError ,атакжеуказаноместо,гдебыла
обнаруженаошибка.Таквданномслучаедействует обработчик ошибок .
16.2 Исключения
Попытаемся считатьчто-либоотпользователя.Нажмите Сtrl-Dипосмотрите,чтопро-
изойдёт.
>>> s=input ('Введите что-нибудь --> ')
Введите что-нибудь -->
Traceback (most recent call last):
File "<pyshell#2>" , line 1, in <module>
119
A Byte of Python (Russian), Версия 2.01
s=input ('Введите что-нибудь --> ')
EOFError : EOF when reading a line
Python поднимает ошибку с именем EOFError, что означает, что он обнаружил символ
конца файла (которыйвводитсяприпомощи Ctrl-D)там,гденеожидал.
16.3 Обработка исключений
Обрабатывать исключения можно при помощи оператора try..except1. При этом все
обычные команды помещаются внутрь try-блока, а все обработчики исключений – в
except-блок.
Пример: (сохранитекак try_except.py )
try:
text =input ('Введите что-нибудь --> ')
except EOFError :
print ('Ну зачем вы сделали мне EOF? ')
except KeyboardInterrupt :
print ('Вы отменили операцию. ')
else :
print ('Вы ввели {0} '.format(text))
Вывод:
$ python3 try_except.py
Введите что-нибудь --> # Нажмите ctrl-d
Ну зачем вы сделали мне EOF?
$ python3 try_except.py
Введите что-нибудь --> # Нажмите ctrl-c
Вы отменили операцию.
$ python3 try_except.py
Введите что-нибудь --> без ошибок
Вы ввели без ошибок
Как это работает:
Здесь мы поместили все команды, которые могут вызвать исключе-
ния/ошибки, внутрь блока try, а затем поместили обработчики соответ-
ствующих ошибок/исключений в блок except. Выражение exceptможет об-
рабатывать как одиночную ошибку или исключение, так и список оши-
бок/исключений в скобках. Если не указано имя ошибки или исключения,
обрабатыватьсябудут всеошибкииисключения.
1try– англ.«пытаться»( прим.перев. )
120 Глава 16. Исключения
A Byte of Python (Russian), Версия 2.01
Помните, что для каждого выражения tryдолжно быть хотя бы одно соответствующее
выражение except.Иначекакойсмыслбылбывблоке try?
Еслиошибкаилиисключениенеобработано,будетвызванобработчикPythonпоумол-
чанию,которыйостанавливаетвыполнениепрограммыивыводитнаэкрансообщение
обошибке.Вышемыужевиделиэтовдействии.
Можно также добавить пункт elseк соответствующему блоку try..except . Этот пункт
будетвыполнентогда,когдаисключенийневозникает.
В следующем примере мы увидим, как можно получить объект исключения для даль-
нейшейработысним.
16.4 Вызов исключения
Исключение можно поднятьпри помощи оператора raise2, передав ему имя ошиб-
ки/исключения,атакжеобъектисключения,которыйнужно выбросить .
Вызываемаяошибкаилиисключениедолжнабытьклассом,которыйпрямоилинепрямо
являетсяпроизводнымоткласса Exception .
Пример: (сохранитекак raising.py )
class ShortInputException (Exception ):
'''Пользовательский класс исключения.'''
def __init__ (self , length, atleast):
Exception .__init__( self )
self .length =length
self .atleast =atleast
try:
text =input ('Введите что-нибудь --> ')
iflen(text) <3:
raise ShortInputException( len(text), 3)
# Здесь может происходить обычная работа
except EOFError :
print ('Ну зачем вы сделали мне EOF? ')
except ShortInputException asex:
print ('ShortInputException: Длина введённой строки -- {0}; \
ожидалось, как минимум, {1} '.format(ex .length, ex .atleast))
else :
print ('Не было исключений. ')
Вывод:
$ python3 raising.py
Введите что-нибудь --> а
2raise– англ.“поднимать”( прим.перев. )
16.4. Вызов исключения 121
A Byte of Python (Russian), Версия 2.01
ShortInputException: Длина введённой строки -- 1; ожидалось, как минимум, 3
$ python3 raising.py
Введите что-нибудь --> абв
Не было исключений.
Как это работает:
Здесьмысоздаёмнашсобственныйтиписключения.Этотновыйтиписклю-
ченияназывается ShortInputException .Онсодержитдваполя: length,храня-
щеедлинувведённоготекста,и atleast,указывающее,какуюминимальную
длинутекстаожидалапрограмма.
В пункте exceptмы указываем класс ошибки ShortInputException , кото-
рыйбудетсохранёнкак3переменная ex,содержащаясоответствующийобъект
ошибки/исключения. Это аналогично параметрам и аргументам при вызове
функции.Внутриэтогопункта exceptмыиспользуемполя lengthиatleast
объектаисключениядлявыводанеобходимыхсообщенийпользователю.
16.5 Try .. Finally
Представим,чтопрограммепроисходитчтениефайлаинеобходимоубедиться,чтообъ-
ектфайлабылкорректнозакрытичтоневозниклоникакогоисключения.Этогоможно
достичьсприменениемблока finally.
Сохранитекак finally.py :
import time
try:
f=open ('poem.txt ')
while True :# наш обычный способ читать файлы
line =f.readline()
iflen(line) ==0:
break
print (line, end ='')
time .sleep( 2)# Пусть подождёт некоторое время
except KeyboardInterrupt :
print ('!! Вы отменили чтение файла. ')
finally :
f.close()
print ('(Очистка: Закрытие файла) ')
Вывод:
3as– англ.«как»( прим.перев. )
122 Глава 16. Исключения
A Byte of Python (Russian), Версия 2.01
$ python3 finally.py
Программировать весело
Если работа скучна,
Чтобы придать ей весёлый тон -
!! Вы отменили чтение файла.
(Очистка: Закрытие файла)
Как это работает:
Здесьмыпроизводимобычныеоперациичтенияизфайла,новданномслу-
чаедобавляемдвухсекундныйсонпослевыводакаждойстрокиприпомощи
функции time.sleep , чтобы программа выполнялась медленно (ведь Python
оченьбыстротприроды).Вовремявыполненияпрограммынажмите ctrl-c,
чтобыпрервать/отменитьвыполнениепрограммы.
Пронаблюдайте, как при этом выдаётся исключение KeyboardInterrupt , и
программа выходит. Однако, прежде чем программа выйдет, выполняется
пункт finally,ифайловыйобъектбудетвсегдазакрыт.
16.6 Оператор with
Типичнойсхемойявляетсязапроснекоторогоресурсавблоке tryспоследующимосво-
бождением этого ресурса в блоке finally. Для того, чтобы сделать это более «чисто»,
существуетоператор with4:
Сохранитекак using_with.py :
with open ("poem.txt ")asf:
for line inf:
print (line, end ='')
Как это работает:
Вывод должен быть таким же, как и в предыдущем примере. Разница лишь
втом,чтоздесьмыиспользуемфункцию openсоператором with–этиммы
оставляемавтоматическоезакрытиефайлаподответственность with open .
Закулисамипроисходитследующее.Существуетнекийпротокол,используе-
мыйоператором with.Онсчитываетобъект,возвращаемыйоператором open.
Назовёмеговданномслучае«theﬁle».
Передзапускомблокакода,содержащегосявнём,оператор with всегдавызы-
ваетфункцию thefile.__enter__ ,атакже всегдавызывает thefile.__exit__
послезавершениявыполненияэтогоблокакода.
Так что код, который мы бы написали в блоке finally, будет автоматически
обработан методом __exit__. Это избавляет нас от необходимости повторно
вявномвидеуказыватьоператоры try..finally .
4with– англ.«с»( прим.перев. )
16.6. Оператор with 123
A Byte of Python (Russian), Версия 2.01
Болееобширноерассмотрениеэтойтемывыходитзарамкинастоящейкниги,
поэтомудляболееисчерпывающегообъяснениясм. PEP 343.
16.7 Резюме
Мыобсудилииспользованиеоператоров try..except иtry..finally .Мытакжеувиде-
ли,каксоздаватьнашисобственныетипыисключенийикакихвызывать.
ДалеемыознакомимсясостандартнойбиблиотекойPython.
124 Глава 16. Исключения
Стандартная библиотека
СтандартнаябиблиотекаPythonсодержитогромноеколичествополезныхмодулейияв-
ляется частью стандартного комплекта поставки Python. Ознакомиться со стандартной
библиотекойPythonоченьважно,таккакмножествозадачможнорешитьоченьбыстро,
есливызнакомысвозможностямиэтихбиблиотек.
Рассмотримнекоторыенаиболеечастоиспользуемыемодулиэтойбиблиотеки.Деталь-
ное описание всех модулей стандартной библиотеки Python можно найти в разделе
«LibraryReference» документации,входящейвкомплектпоставкиPython.
Давайтеизучимнесколькополезныхмодулей.
Примечание
Если темы в настоящей главе покажутся вам слишком сложными, вы можете её пропу-
стить. Однако я настоятельно рекомендую вернуться к этой главе, когда вы будете чув-
ствоватьсебяболееуверенносPython.
17.1 Модуль sys
Модуль sysсодержитфункциональность,характернуюдлясистемы.Такмывидели,что
список sys.argv содержитаргументыкоманднойстроки.
Предположим,намнужноузнатьверсиюиспользуемойкомандыPythonстем,чтобы,к
примеру,убедитьсявтом,чтомыиспользуемкакминимумверсию3.Модуль sysпредо-
ставляеттакуювозможность.
>>> import sys
>>> sys.version_info
(3, 0, 0, 'beta', 2)
>>> sys.version_info[ 0]>=3
True
Как это работает:
Модуль sysсодержит кортеж version_info , который хранит информацию о
версии. Первый элемент этого кортежа обозначает старшую версию. Мы мо-
125
A Byte of Python (Russian), Версия 2.01
жем использовать его, например, для того, чтобы убедиться, что программа
будетвыполнятьсятольковPython3.0:
Сохранитекак versioncheck.py :
import sys,warnings
ifsys.version_info[ 0]<3:
warnings .warn( "Для выполнения этой программы необходима как минимум \
версия Python 3.0 ",
RuntimeWarning )
else :
print ('Нормальное продолжение ')
Вывод:
$ python2.7 versioncheck.py
versioncheck.py:6: Для выполнения этой программы необходима как минимум
версия Python 3.0
RuntimeWarning)
$ python3 versioncheck.py
Нормальное продолжение
Как это работает:
Мыиспользуемодинизмодулейстандартнойбиблиотеки,которыйназыва-
ется warnings ислужитдляотображенияпредупрежденийпользователю.Ес-
ливерсияPythonменее3,мыпоказываемсоответствующеепредупреждение.
17.2 Модуль logging
Представьтеситуацию,когданеобходимосохранитьнекоторыеотладочныеилидругие
важные сообщения где-нибудь, чтобы иметь возможность позже проверить, отработала
липрограмма,какожидалось.Какмы‘«сохранимгде-нибудь»этисообщения?Сделать
этоможноприпомощимодуля logging.
Сохранитекак use_logging.py :
import os,platform ,logging
ifplatform .platform() .startswith( 'Windows '):
logging_file =os.path .join(os .getenv( 'HOMEDRIVE '), \
os.getenv( 'HOMEPATH '), \
'test.log ')
else :
logging_file =os.path .join(os .getenv( 'HOME '),'test.log ')
print ("Сохраняем лог в ", logging_file)
126 Глава 17. Стандартная библиотека
A Byte of Python (Russian), Версия 2.01
logging .basicConfig(
level =logging .DEBUG,
format ='%(asctime)s :%(levelname)s :%(message)s ',
filename =logging_file,
filemode ='w',
)
logging .debug( "Начало программы ")
logging .info( "Какие-то действия ")
logging .warning( "Программа умирает ")
Вывод:
$ python3 use_logging.py
Сохраняем лог в C:\Users\swaroop\test.log
Еслиоткрытьфайл test.log,онбудетвыглядетьпримернотак:
2012-10-26 16:52:41,457 : DEBUG : Начало программы
2012-10-26 16:52:41,474 : INFO : Какие-то действия
2012-10-26 16:52:41,475 : WARNING : Программа умирает
Как это работает:
Мыиспользовалитримодуляизстандартнойбиблиотеки:модуль osдлявза-
имодействиясоперационнойсистемой,модуль platform дляполученияин-
формацииоплатформе(т.е.операционнойсистеме)имодуль loggingдлясо-
хранениялога1.
Прежде всего, при помощи строки, возвращаемой функцией
platform.platform() мы проверяем, какая операционная система ис-
пользуется (для более подробной информации см. import platform;
help(platform) ). Если это Windows, то мы определяем диск, содержащий
домашний каталог, путь к домашнему каталогу на нём и имя файла, в кото-
ром хотим сохранить информацию. Сложив все эти три части, мы получаем
полный путь к файлу. Для других платформ нам нужно знать только путь к
домашнемукаталогупользователя,имыполучимполныйпутькфайлу.
Припомощифункции os.path.join() мыобъединяемтричастипутикфай-
лу вместе.Мыиспользуемэту функцию вместопростого объединениястрок
длятого,чтобыгарантировать,чтополныйпутькфайлузаписанвформате,
ожидаемомоперационнойсистемой.
Далее мы конфигурируем модуль loggingтаким образом, чтобы он записы-
валвсесообщениявопределённомформатевуказанныйфайл.
Наконец,мыможемвыводитьсообщения,предназначенныедляотладки,ин-
формирования, предупреждения и даже критические сообщения. После вы-
полнения программы можно просмотреть этот файл и узнать, что происхо-
1log– англ.«журнал»,«вестижурнал»( прим.перев. )
17.2. Модуль logging 127
A Byte of Python (Russian), Версия 2.01
дило в программе, хотя пользователю, запустившему программу, ничего не
былопоказано.
17.3 Серия «Модуль недели»
Встандартнойбиблиотекеможнонайтиещёмногополезного.Например, отладка,обра-
боткапараметровкоманднойстроки ,регулярныевыражения итакдалее.
Лучший способ дальнейшего изучения стандартной библиотеки – читать замечатель-
нуюсериюДугаХелмана «Модульнедели» илиофициальную документациюPython .
17.4 Резюме
Мыизучилилишьнекоторыевозможностинекоторыхмодулейстандартнойбиблиоте-
киPython.Янастоятельнорекомендуюпросмотреть документациюпостандартнойбиб-
лиотекеPython ,чтобыувидетьвседоступныемодули.
Далеемыобратимсякнекоторымаспектам,которыесделаютвашуэкскурсиюпоPython
более«завершённой».
128 Глава 17. Стандартная библиотека
Дополнительно
К настоящему моменту мы уже рассмотрели большую часть того, что вам придётся ис-
пользовать при работе с Python. В этой главе мы охватим некоторые дополнительные
аспекты,которыепомогутотшлифоватьвашизнания.
18.1 Передача кортежей
Хотелосьливамкогда-нибудь,чтобыфункциявозвращаланеодинрезультат,адва?Это
возможно.Всё,чтодляэтогонужно,–использоватькортеж.
>>> def get_error_details ():
... return (2,'описание ошибки No2 ')
...
>>> errnum, errstr =get_error_details()
>>> errnum
2
>>> errstr
'описание ошибки No2'
Обратите внимание, что использование выражения “ a, b = <некоторое выражение> ”
интерпретируетрезультаткаккортежиздвухзначений.
Чтобыинтерпретироватьрезультаткак“ (a, <всё остальное>) ”,нужнопростопоставить
звёздочку,какэтоделалосьдляпараметровфункций:
>>> a,*b=[1,2,3,4]
>>> a
1
>>> b
[2, 3, 4]
Это также подразумевает, что поменять местами два значения в Python быстрее всего
можнотак:
>>> a=5; b =8
>>> a, b =b, a
>>> a, b
(8, 5)
129
A Byte of Python (Russian), Версия 2.01
18.2 Специальные методы
Естьрядметодов,играющихособуюрольдляклассов.Например, __init__ и__del__.
Специальныеметодыслужатдлятого,чтобыимитироватьповедениевстроенныхтипов
данных. Например, всё, что потребуется для использования операции индексирования
x[индекс] применительно к своему классу (в таком виде, как это делалось для списков
и кортежей), это реализовать метод __getitem__() . Кстати, именно этот метод Python
используетдлясамогокласса list!
Некоторыеполезныеспециальныеметодыперечисленывтаблицениже.Вседругиеме-
тодыможнопосмотретьв документации .
Имя Описание
__init__(self,…) Этотметодвызываетсяпрямопередтем,каквновьсозданный
объектвозвращаетсядляиспользования.
__del__(sel) Вызываетсяпередуничтожениемобъекта
__str__(sel) Вызываетсяприиспользованиифункции printили str().
__lt__(self,other) Вызывается,когдаиспользуетсяоператор«меньше»(<).
Существуютианалогичныеметодыдлявсехоператоров(+,>,
ит.д.)
__getitem__(self,key) Вызываетсяприиспользованииоператораиндексирования
x[индекс]
__len__(sel) Вызываетсяприобращенииквстроеннойфункции len()для
объекта-последовательности.
18.3 Блоки в одно выражение
Мы неоднократно говорили, что каждый блок команд отделяется от других своим соб-
ственнымуровнемотступа.Однако,существуетиисключение.Еслиблоккомандсодер-
життолькоодновыражение,егоможноуказыватьводнойстрокесусловнымоператором
или,скажем,операторомцикла.Рассмотримэтонапримере:
>>> flag =True
>>> ifflag: print ('Да')
Да
Обратитевнимание,чтоединственныйоператоррасположенвтойжестроке,анеотдель-
нымблоком.Этотспособможетподкупитьтем,чтоякобы«сокращает»программу,ноя
настоятельнорекомендуюизбегатьегововсехслучаях,кромепроверкиошибок.Прежде
всего,потомучтогораздолегчедобавлятькоманды,когдаужеестьнеобходимыйуровень
отступа.
130 Глава 18. Дополнительно
A Byte of Python (Russian), Версия 2.01
18.4 Lambda-формы
Ключевое слово lambdaиспользуется для создания функций и возврата их значения во
время выполнения программы. lambdaпринимает параметр, за которым следует одно
выражение,котороестановитсятеломфункции,азначениеэтоговыражениявозвраща-
етсяновойфункцией.
Пример: (сохранитекак lambda.py )
points =[ { 'x':2,'y':3}, { 'x':4,'y':1} ]
points .sort(key =lambda i : i[ 'y'])
print (points)
Вывод:
$ python3 lambda.py
[{'x': 4, 'y': 1}, {'x': 2, 'y': 3}]
Как это работает:
Обратитевниманиенато,чтометод sortкласса listможетприниматьпара-
метр key,определяющийспособсортировкисписка(обычномыдумаемтоль-
коосортировкеповозрастаниюилипоубыванию).Вданномслучаемыхотим
провести сортировку по собственному принципу, для чего нам необходимо
написатьсоответствующуюфункцию.Новместотого,чтобысоздаватьотдель-
ныйблок defдляописанияфункции,котораябудетиспользоватьсятольков
этомместе,мыприменяемлямбда-выражение.
18.5 Генераторы списков
Генераторысписковслужатдлясозданияновыхсписковнаосновесуществующих.Пред-
ставьте,чтоимеетсясписокчисел,наосновекотороготребуетсяполучитьновыйсписок,
состоящийизвсехчисел,умноженныхна2,нотолькоприусловии,чтосамочислоболь-
ше2.Генераторысписковподходятдлятакихзадачкакнельзялучше.
Пример: (сохранитекак list_comprehension.py )
listone =[2,3,4]
listtwo =[2*ifor iinlistone ifi>2]
print (listtwo)
Вывод:
$ python3 list_comprehension.py
[6, 8]
Как это работает:
18.4. Lambda-формы 131
A Byte of Python (Russian), Версия 2.01
В этом примере мы создаём новый список, указав операцию, которую необ-
ходимопроизвести( 2 * i),когдавыполняетсянекотороеусловие( if i > 2).
Обратитевнимание,чтоисходныйсписокприэтомнеизменяется.
Преимущество использования генераторов списков состоит в том, что это заметно со-
кращаетобъёмыстандартногокода,необходимогодляциклическойобработкикаждого
элементаспискаисохраненияеговновомсписке.
18.6 Передача кортежей и словарей в функции
Дляполученияпараметров,переданныхфункции,ввидекортежаилисловаря,существу-
ютспециальныеприставки“ *”или“ **”соответственно.Этоособеннополезновслучаях,
когдафункцияможетприниматьпеременноечислопараметров.
>>> def powersum (power, *args):
... '''Возвращает сумму аргументов, возведённых в указанную степень.'''
... total =0
... for iinargs:
... total +=pow(i, power)
... return total
...
>>> powersum( 2,3,4)
25
>>> powersum( 2,10)
100
Поскольку перед переменной argsуказана приставка “ *”, все дополнительные аргу-
менты, переданные функции, сохранятся в argsв виде кортежа. В случае использова-
ния приставки “ **” все дополнительные параметры будут рассматриваться как пары
ключ/значениевсловаре.
18.7 exec и eval
Функция execслужитдлявыполнениякомандPython,содержащихсявстрокеилифай-
ле,вотличиеотсамоготекстапрограммы.Например,вовремявыполненияпрограммы
можно сформировать строку, содержащую текст программы на Python, и запустить его
припомощи exec:
>>> exec ('print( "Здравствуй, Мир! ")')
Здравствуй, Мир!
Аналогично, функция evalпозволяет вычислять корректные выражения Python, содер-
жащиесявстроке.Вотпростойпример.
132 Глава 18. Дополнительно
A Byte of Python (Russian), Версия 2.01
>>> eval ('2*3')
6
18.8 Оператор assert
Оператор assertсуществуетдлятого,чтобыуказать,чтонечтоявляетсяистиной.Напри-
мер, если требуется гарантировать, что в списке будет хотя бы один элемент, и вызвать
ошибку,еслиэтонетак,тооператор assertидеальноподойдётдлятакойзадачи.Когда
заявленноевыражениеложно,вызываетсяошибка AssertionError .
>>> mylist =['item ']
>>> assert len(mylist) >=1
>>> mylist .pop()
'item'
>>> mylist
[]
>>> assert len(mylist) >=1
Traceback (most recent call last):
File "<stdin>" , line 1, in <module>
AssertionError
Темнеменее,оператор assertследуетиспользоватьблагоразумно.Вбольшинствеслуча-
евгораздолучше«отлавливать»исключенияилиборешатьсоответствующуюпроблему
автоматически, либо выдавать пользователю сообщение об ошибке и завершать работу
программы.
18.9 Функция repr
Функция reprиспользуется для получения канонического строкового представления
объекта.Любопытно,чтовбольшинствеслучаев eval(repr(object)) == object .
>>> i=[]
>>> i.append( 'item ')
>>> repr (i)
"['item']"
>>> eval (repr (i))
['item']
>>> eval (repr (i)) ==i
True
По большому счёту, функция reprслужит для получения печатаемого представления
объекта. Определив метод __repr__ в собственном классе, можно указать, что он будет
возвращатьповызовуфункции repr.
18.8. Оператор assert 133
A Byte of Python (Russian), Версия 2.01
18.10 Управляющие последовательности
Попробуйтеответитьнавопрос:Какуказатьстроку,содержащуюодинарнуюкавычку( ')?
Например,строку“ What's your name? ”.Еёведьнельзязаписатьпростокак“ 'What's your
name?'”,потомучтотогдаPythonнесможетопределить,гденачалостроки,игдеконец.
В таком случае придётся каким-то образом указать, что данная одинарная кавычка не
обозначаетконцастроки.Этоможносделатьприпомощитакназываемой управляющей
последовательности .Укажитеодинарнуюкавычкукак \'–черезобратнуюкосуючерту.
Теперьнашастрокабудетвыглядетьтак: 'What\'s your name?' .
Другойспособзаписитакойспецифическойстроки– "What's your name?" ,т.е.сисполь-
зованиемдвойныхкавычек.Аналогичноследуетиспользоватьуправляющуюпоследова-
тельностьдлявставкидвойнойкавычкивстроку,ограниченнуюдвойнымикавычками.
Самажеобратнаянаклоннаячертауказываетсяуправляющейпоследовательностью \\.
А как записать двустрочную строку? Один из вариантов нам уже знаком – заключить
строку в тройные кавычки, как было показано ранее. Но есть и другой – использовать
управляющуюпоследовательностьдлясимволапереводастроки \n.Например:“ Это пер-
вая строка\nЭто вторая строка ”.Полезнознатьещёоднууправляющуюпоследователь-
ность–табуляцию( \t).Управляющихпоследовательностейсуществуетнамногобольше,
ноздесьупомянутытольконаиболееважные.
Следуетотметить,чтоодинарнаянаклоннаячертавконцестрокилишьуказываетнато,
чтопродолжениеидётстрокойниже,ноневставляетпереводастроки.Например:
"Это первое предложение. \
Это второе предложение. "
эквивалентнозаписи "Это первое предложение. Это второе предложение." .
18.11 Необрабатываемые строки
Длязаписистроки,вкоторойнебудетпроводитьсяникакойспециальнойобработки,как,
например,управляющихпоследовательностей,передстрокойуказываетсяприставка“ r”
или“ R”1.Например, r"Перевод строки обозначается \n" .
Замечание для пользователей регулярных выражений
Дляработысрегулярнымивыражениямивсегдаиспользуйтенеобрабатываемыестроки.
Впротивномслучаевасждётмноговознисобратнымикосымичёрточками.Например,
обратныессылкиможнообозначатькак '\\1'или r'\1'.
1“r”– от англ.«raw»–«сырой,необработанный»( прим. перев. )
134 Глава 18. Дополнительно
A Byte of Python (Russian), Версия 2.01
18.12 Резюме
Итак, в настоящей главе мы рассмотрели некоторые дополнительные возможности
Python, хотя по-прежнему, не охватили всего. Тем не менее, к настоящему моменту мы
ужепрошлипочтивсё,чтовамкогда-либопонадобитсяиспользоватьнапрактике.Этого
вполнедостаточнодляначалаработынадлюбымипрограммами.
Далеемыобсудим,какпродолжатьисследоватьPython.
18.12. Резюме 135
A Byte of Python (Russian), Версия 2.01
136 Глава 18. Дополнительно
Что дальше
Добросовестный читатель, дочитавший книгу до сих пор, а также много практиковав-
шийсявнаписаниипрограмм,навернякаужеосвоилсясPython.Иконечно,выужепо-
пробовалиреализоватькакие-нибудьсобственныеидеинаPython,чтобыпотренировать-
ся. Нет? Тогда стоит начать! Но в таком случае возникает вопрос: «Что же делать даль-
ше?».
Япредлагаювамсправитьсясоследующейзадачей.
Задача
Создайте собственную программу «Адресная книга», работающую из командной стро-
киипозволяющуюпросматривать,добавлять,изменять,удалятьилиискатьконтактные
данныевашихзнакомых.Крометого,этаинформациятакжедолжнасохранятьсянадис-
кедляпоследующегодоступа.
Это достаточно простая задача, если думать о ней в терминах, которые мы до сих пор
проходили.Еслижевывсё-такинуждаетесьвподсказке,какдействовать,вотона.
Подсказка (не читать!)
Создайтеклассдляхраненияперсональныхданных.Объектывизитныхкарточекхрани-
те в словаре, в котором имена контактов будут служить ключами. Для длительного хра-
нения этих объектов на жёстком диске воспользуйтесь модулем pickle. Для добавления,
измененияилиудаленияконтактовприменяйтевстроенныеметодысловаря.
Кактольковысправитесьсэтим,высмеломожетеназыватьсяпрограммистомнаPython.
Атеперьнемедленно напишитемнеписьмо ;-).Этонеобязательныйшаг,новесьмаре-
комендуемый. Также подумайте о покупке бумажной версии книги , чтобы поддержать
еёдальнейшуюразработку.
Еслиэтазадачкапоказаласьвамслишкомлёгкой,попробуйтеещёодну:
Задача
Реализуйтекоманду replace.Этакомандазаменяетоднустрокудругойвспискепередан-
ныхейфайлов.
137
A Byte of Python (Russian), Версия 2.01
Команда replaceможет быть любой желаемой сложности: от простой замены строк до
поискапошаблону(регулярномувыражению).
Авотещёнекоторыевозможныенаправлениявашегодальнейшегопутешествияпоми-
руPython:
19.1 Упражнения
На Stack Overﬂow есть неплохое обсуждение упражнений на Python, помогающих отто-
читьвашемастерство .
19.2 Примеры программ
Лучшийспособовладетьязыкомпрограммирования–этописатьмногопрограммичи-
татьмногопрограмм:
•ПроектPLEAC
•ХранилищекодаRosea
•ПримерыдляPythonнаjava2s
•Книга рецептов Python – ценнейшая коллекция рецептов и подсказок, как решать
теилииныепроблемыприпомощиPython.Обязательнакпрочтениюкаждымпро-
граммистомнаPython.
•Модуль недели – ещё один замечательный путеводитель по стандартной библио-
теке Python .
19.3 Вопросы и ответы
•Официальные«Можноинельзя»вPython
•ОфициальныеЧаВоPython
•СписокНеЧастозадаваемыхВопросовотNorvig
•ВопросыиответыизинтервьюоPython
•ВопросынаStackOverﬂowспометкой«python»
19.4 Советы и рекомендации
•ТрюкииуловкиPython
•СколачиваемпрограммыприпомощиPython
•ОчаровательныйPython –замечательнаясериястатейоPythonДэвидаМерца.
138 Глава 19. Что дальше
A Byte of Python (Russian), Версия 2.01
19.5 Учебники
•ВсеобъемлющийсписокучебниковпоPythonотAwaretek
19.6 Видео
•PyVideo
19.7 Обсуждение
Есливызастрялинакакой-топроблемевPythonинезнаете,когоспросить,тогда список
рассылкиpython-tutor подойдётнаилучшимобразом.
Темнеменее,сначалапроделайтевсюдомашнююработуипопытайтесьрешитьпробле-
мусамостоятельно.
19.8 Новости
ЕсливасинтересуютпоследниеновостимираPython,отслеживайтеихнаофициальной
планетеPython .
19.9 Установка библиотек
ВКаталогепакетовPython существуетколоссальноеколичествооткрытыхбиблиотек,ко-
торыевыможетеиспользоватьвсвоихпрограммах.Дляихустановкиможновоспользо-
ватьсяpip.
19.10 Графические программы
ДлясозданиясобственнойграфическойпрограммынаPythonпонадобитсякакая-нибудь
библиотека ГИП (графического интерфейса пользователя) со своими привязками к
Python. Привязки позволяют писать программу на Python, используя библиотеки, кото-
рыесамипосебенаписанынаC,C++илидругихязыках.
ВыборГИПдляPythonдостаточнообширен:
•Kivy
hp://kivy.org
19.5. Учебники 139
A Byte of Python (Russian), Версия 2.01
•PyGTK
Это привязки Python к инструментарию GTK+, на основе которого построен
GNOME. У GTK+ есть много своих особенностей, но как только вы освоитесь, вы
сможетесоздаватьГИПоченьбыстро.Чтокасаетсядизайнераграфическогоинтер-
фейсаGlade,тоонпростонезаменим.Документацияжевсёещётребуетнекоторых
улучшений. GTK+ хорошо работает в GNU/Linux, но его порт на Windows пока не
закончен.ПрипомощиGTK+можносоздаватькаксвободные,такипроприетарные
программы.Дляначалапрочитайте УчебникпоPyGTK .
•PyQt
Это привязки Python к инструментарию Qt, на основе которого построена KDE. Qt
чрезвычайнопроствиспользовании,особенноблагодаряQtDesignerиизумитель-
нойдокументацииQt.PyQtбесплатно,еслииспользуетсядлясозданиясвободных
программ (с лицензией GPL). Для создания закрытых проприетарных программ
вампридётсяегокупить.НачинаясQt4.5,разрешаетсясоздаватьприпомощинего
нетолькоGPL’ныепрограммы.Дляначалапрочитайте краткоепособиепоPyQt или
КнигуPyQt .
•wxPython
ЭтопривязкиPythonкинструментариюwxWidgets.wxPythonнетакпроствосвое-
нии,нозатоонпереносимиработаетнаGNU/Linux,Windows,Macидаженавстраи-
ваемыхплатформах.МногиесредыразработкидляwxPython,такиекак SPE(Stani’s
Python Editor) иwxGladeвключают дизайнеры графического интерфейса. При по-
мощиwxPythonможносоздаватькаксвободные,такипроприетарныепрограммы.
Дляначалапрочитайте учебникпоwxPython .
19.11 Резюме по инструментам ГИП
Другие варианты можно найти на wiki-странице GuiProgramming официального сайта
Python.
К сожалению, не существует некоего единого стандартного инструмента для создания
графических программ на Python. Я бы рекомендовал выбирать один из инструментов,
описанныхвыше,наиболееподходящийдляконкретнойситуации.Во-первых,опреде-
литесь, согласны ли вы платить за использование этого инструмента. Во-вторых, опре-
делитесь,накакихплатформахдолжнаработатьвашапрограмма:тольконаWindows,на
MacиGNU/Linuxилинавсехсразу.Ив-третьих,есливывыбралиплатформуGNU/Linux,
товкакойсредевыработаете:вKDEилиGNOME.
Дляболееподробногоанализасм.страницу26 СтатейоPython,Том3,Выпуск1 .
140 Глава 19. Что дальше
A Byte of Python (Russian), Версия 2.01
19.12 Различные реализации
Языкпрограммированияобычносостоитиздвухчастей:собственноязыкаипрограмм-
ногообеспечения.Язык–этото, какмычто-либопишем,апрограммноеобеспечение–
этото, чтозапускаетнашипрограммы.
Досихпордлявыполнениянашихпрограмммыиспользовали CPython.Онназывается
«CPython», потому что написан на языке C и является Классическим интерпретатором
Python1.
Носуществуетидругоепрограммноеобеспечение,способноевыполнятьпрограммына
Python:
•Jython
Реализация Python, работающая на платформе Java. Это означает, что можно ис-
пользоватьбиблиотекииклассыJavaвпрограмменаPythonинаоборот.
•IronPython
РеализацияPython,работающаянаплатформе.NET,чтоозначаетвозможностьис-
пользованиябиблиотекиклассов.NETвпрограммахнаPythonинаоборот.
•PyPy
Реализация Python, написанная на Python! Это исследовательский проект, суще-
ствующийдляускоренияиоблегченияразработкиинтерпретатора,посколькусам
интерпретаторнаписаннадинамическомязыке(вотличиеотстатическихязыков,
какC,JavaиC#ввышеупомянутыхреализациях)
•StacklessPython
РеализацияPython,специализирующаясянавысокойпроизводительностимного-
поточныхпрограмм.
Существуют и другие реализации, такие как CLPython – написанная на Common Lisp и
IronMonkey –портIronPythonнаJavaScript,чтодаётвозможностьписатьбраузерныепри-
ложения(«Ajax»)наPythonвместоJavaScript.
Каждаяизперечисленныхреализацийимеетсвоюобластьприменения.
19.13 Функциональное программирование (для хо-
рошо подготовленных читателей)
Длянаписаниябольшихпрограммопределённонеобходимоизучитьфункциональный
подход к программированию, в отличие от объектно-ориентированного подхода, кото-
рыймыпроходилив разделе «Объектно-ориентированное программирование» :
•Практическиесоветыпофункциональномупрограммированию,A.M.Kuchling
1Classical Pythoninterpreter( прим.перев. )
19.12. Различные реализации 141
A Byte of Python (Russian), Версия 2.01
•Глава«Функциональноепрограммирование»книги«DiveIntoPython»
•Презентация«ФункциональноепрограммированиевPython»
19.14 Резюме
Вотмыиподошликконцунашейкниги,нокакговорится,этотолько начало конца !Те-
перьвызаядлыйпрограммистнаPython,инесомненно,готовырешатьмножествозадач
при помощи Python. Теперь вы можете начать автоматизировать на своём компьютере
всёподряд,можетеписатьсобственныеигрыимногое-многоедругое.Такчтовперёд!
142 Глава 19. Что дальше
Приложение: FLOSS
20.1 Free/Libre and Open Source Software (FLOSS)1
В основу идеи FLOSSположена концепция сообщества, в котором принято делиться, и
особенноделитьсязнаниями.Свободныепрограммыможносвободноиспользовать,из-
менятьираспространять.
Есливыужепрочлиэтукнигу,товыужезнакомысосвободнымПО,таккаквыизучали
Pythonвсёэтовремя,аPythonявляетсясвободнымпрограммнымобеспечением!
Вот несколько примеров свободного ПО, по которым можно составить некоторое пред-
ставлениеотом,чтоспособносоздатьтакоесообщество:
•Linux.Этосвободноеядрооперационнойсистемы,используемое,например,вопе-
рационной системе GNU/Linux. Разработку ядра «Linux» начал Линус Торвальдс
ещёвсвоюбытностьстудентом.[ LinuxKernel ]
•GNU. Свободная операционная система, основанная Ричардом Столлманом в 1983
году.[GNU]
•GNU/Linux . Сочетание операционной системы GNU с ядром «Linux», в наше вре-
мя серьёзный конкурент Microso Windows. В принципе, GNU/Linux является сво-
бодным программным обеспечением, но разные дистрибутивы GNU/Linux могут
включатьинесвободныепрограммы.[ FreeGNU/Linuxdistributions ]
•Ubuntu. Это дистрибутив, разрабатываемый сообществом и спонсируемый фир-
мой Canonical. В настоящее время это, пожалуй, самый популярный дистрибутив
GNU/Linux. Он позволяет легко устанавливать и использовать множество свобод-
ныхпрограмм.Большетого,онпозволяетпростоперезагрузитьвашкомпьютери
запуститьGNU/LinuxсCD!Этодаётвозможностьвполноймереопробоватьновую
операционную систему до установки на жёсткий диск. Однако, Ubuntu не полно-
стьюсвободна,таккаквключаетнекоторыепроприетарныедрайверы,микрокоди
приложения.[ Ubuntu]
•LibreOﬃce . Это превосходный офисный пакет, разрабатываемый сообществом и
включающий в себя компоненты для создания текста, презентаций, электронных
таблиц, рисунков и многого другого. Он также позволяет открывать и редактиро-
вать файлы MS Word и MS Powerpoint. Он работает практически на всех платфор-
1Свободноеиоткрытоепрограммноеобеспечение( прим.перев. )
143
A Byte of Python (Russian), Версия 2.01
мах и является полностью свободным и открытым программным обеспечением.
[LibreOﬃce ]
•Mozilla Firefox .Этовеб-браузерновогопоколения,являющийсясильнейшимсопер-
никомInternetExplorer.Оногненнобыстр,изаработалширокоепризнаниесвоими
удобнымиивпечатляющимивозможностями.Аконцепциярасширенийпозволя-
етдополнятьегосамымиразнообразнымиплагинами.[ MozillaFirefox ]
•Его«напарник» underbird –отличныйклиентэлектроннойпочты,делающийеё
чтениечрезвычайнопростым.[ Mozillaunderbird ]
•Mono. Это свободная реализация платформы Microso .NET. Она позволяет созда-
ватьизапускать.NET-приложениявGNU/Linux,Windows,FreeBSD,MacOSинамно-
гихдругихплатформах.[ Mono],[ECMA],[.NET]
•Apae web server . Это популярный открытый веб-сервер. По сути, это самыйпо-
пулярныйвеб-сервернапланете.Нанёмработаетболееполовинывсехсайтов.Да,
Apacheдействительнообслуживаетбольшесайтов,чемвсеостальныевеб-серверы
(включаяMicrosoIIS)вместевзятые.[ Apache]
•MySQL. Это чрезвычайно популярный открытый сервер баз данных. Он наиболее
известенсвоейошеломляющейскоростью.Этоегообозначаютбуквой«M»всоче-
тании«LAMP»,накоторомработаетбольшинствосайтоввИнтернете.[ MySQL]
•VLC Player . Это проигрыватель, который может воспроизводить всё, начиная от
DivX и до MP3, до Ogg, до VCD, до DVD, до … и кто сказал, что это не забавно? ;-)
[VLCmediaplayer ]
•GeexBox– дистрибутив GNU/Linux, созданный для проигрывания фильмов сразу
послезагрузкисCD![ GeexBox]
Этот список предназначен только лишь для того, чтобы вкратце передать вам мысль,
на самом же деле существует ещё огромное множество свободного ПО, такого как язык
Perl, язык PHP, система управления содержимым веб-сайтов Drupal, сервер баз данных
PostgreSQL, игра TORCS, среда разработки KDevelop, проигрыватель Xine, текстовый ре-
дакторVIM,редакторanta+,аудио-плеерBanshee,графическийредакторGIMP,…этот
списокможнопродолжатьвечно.
ЧтобыотследитьсвежиеслухивмиресвободногоПО,посетитеследующиесайты:
•linux.com
•LinuxToday
•NewsForge
•DistroWatch
УзнатьбольшеосвободномПОможнонаследующихсайтах:
•SourceForge
•FreshMeat
Такчтовперёд–осваиватьбескрайний,свободныйиоткрытыймирСПО!
144 Глава 20. Приложение: FLOSS
Приложение: о книге
21.1 Колофон
Практически все программы, которые я использовал при написании этой книги, явля-
ются свободными .
21.1.1 Рождение книги
При написании первого черновика этой книги в основе моей системы была Red Hat 9.0
Linux,ноужешестуюверсиючерновикаяписалнаFedoraCore3Linux.
ВначаледлянаписаниякнигияиспользовалKWord(какяиописывалв Предисловии ).
21.1.2 Отрочество
Позже я перешёл на формат DocBook XML и использовал Kate, но это показалось мне
слишком скучным. Поэтому я перешёл на OpenOﬃce, который замечательно подходил
сосвоимуровнемуправленияформатированиемивозможностьюгенерироватьPDF,но
онвыдавалслишкомнебрежныеHTML-страницы.
Наконец, я открыл для себя XEmacs и переписал всю книгу с нуля в формате DocBook
XML(снова),таккакрешил,чтоэтотформат–надолго.
Для шестой версии черновика я решил использовать anta+. При этом я использовал
стандартныетаблицыстилейXSL,которыешливкомплектесFedoraCore3Linux.Потом
я написал CSS документ, чтобы придать цвет и стиль HTML-страницам. Я такжена ско-
рую руку написал лексический анализатор (конечно, на Python), который осуществлял
автоматическуюподсветкусинтаксисавпримерахпрограмм.
Для седьмой редакции я использовал MediaWiki в качестве основы для своего сай-
та. Теперь я всё редактирую прямо на сайте, а читатели могут сразу же чи-
тать/редактировать/обсуждатьсодержимоенавики-странице.
Благодаря расширениюViewSourceWithдляFirefox ,котороеинтегрируетсясVim,япро-
должалиспользоватьVimдляредактирования.
145
A Byte of Python (Russian), Версия 2.01
21.1.3 Сейчас
Использую Vim,Pandoc,иMacOSX.
21.2 Об авторе
hp://www.swaroopch.com/about/
146 Глава 21. Приложение: о книге
Приложение: История версий
•2.0(20/10/2012)
–Переписановформате PandocСпасибомоейжене,котораяперевелабольшую
частьтекстаизформатаMediawiki
–Упрощение текста, удаление таких необязательных разделов, как nonlocal и
метаклассы
•1.90(04/09/2008)
–Возобновлениепослеперерывав3.5года!
–ОбновлениедляPython3.0
–Переписановформате MediaWiki (снова)
•1.20(13/01/2005)
–Полностьюпереписанов anta+наFedoraCore3сомножествомисправлений
идополнений.Многоновыхпримеров.ЗановопереписанформатDocBook.
•1.15(28/03/2004)
–Незначительныеисправления.
•1.12(16/03/2004)
–Дополненияиисправления.
•1.10(09/03/2004)
147
A Byte of Python (Russian), Версия 2.01
–Исправления опечаток, благодаря множеству отзывов заинтересованных чи-
тателей.
•1.00(08/03/2004)
–После колоссального числа отзывов и предложений от читателей я произвёл
значительнуюпереработкутекстанарядусисправлениемопечаток.
•0.99(22/02/2004)
–Добавленановаяглаваомодулях.Такжедобавленфрагментопеременномчис-
леаргументоввфункциях.
•0.98(16/02/2004)
–Написан скрипт на Python и таблица стилей CSS для улучшения вывода в
XHTML, включая недоделанный-но-функциональный лексический анализа-
тордляподсветкисинтаксисавпримерахпрограмм
•0.97(13/02/2004)
–Ещё один заново переписанный черновик в формате DocBook XML (снова).
Книгасущественноулучшена–онасталазначительноболеесвязаннойичи-
табельной.
•0.93(25/01/2004)
–ДобавленоописаниеIDLEидругиевещи,относящиесякWindows.
•0.92(05/01/2004)
–Изменениявнесколькихпримерах.
•0.91(30/12/2003)
–Исправленыопечатки.Сделанынаброскимногихразделов.
148 Глава 22. Приложение: История версий
A Byte of Python (Russian), Версия 2.01
•0.90(18/12/2003)
–Добавлены2главы.Формат OpenOﬃce сисправлениями.
•0.60(21/11/2003)
–Полностьюпереписаноирасширено.
•0.20(20/11/2003)
–Исправленынекоторыеопечаткииошибки.
•0.15(20/11/2003)
–Переведеновформат DocBookXML припомощиXEmacs.
•0.10(14/11/2003)
–Самыйпервыйнабросоквредакторе KWord.
149
A Byte of Python (Russian), Версия 2.01
150 Глава 22. Приложение: История версий
Приложение: Инструкция по переводу
Полный исходный текст книги доступен в Git-репозитории
hps://github.com/swaroopch/byte_of_python .
Создайтеответвлениерепозитория .
Затемскачайтерепозиторийнасвойкомпьютер.Дляэтогонужнобытьзнакомымс Git.
Отредактируйтефайлы .pdнасвоёмродномязыке.Прочитайте PandocREADME ,чтобы
познакомитьсясформатированиемтекста
Затем следуйте указаниям в README для установки программ, необходимых для кон-
вертированияисходныхфайловвPDFит.п.
151
В настоящее время Swaroop C H является инженером-менеджером группы 
машинного обучения в Helpshift (автоматизация обслуживания клиентов). 
Ранее он был ранним сотрудником компании  Automatic (приобретенной 
SiriusXM). Он является автором книги для начинающих “A Byte of Python”.
